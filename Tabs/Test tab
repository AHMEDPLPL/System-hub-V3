return function(Window, OrionLib)


--[[ Services ]]--

local Area = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local StarterGui = game:GetService("StarterGui")

--[[ VARIABLES ]]--

local IsOnMobile = table.find({
	Enum.Platform.IOS,
	Enum.Platform.Android
}, UserInputService:GetPlatform())
local player = Players.LocalPlayer
local character = player.Character
local char = character 
local Player = game.Players.LocalPlayer
local Humanoid = Character and Character:FindFirstChildWhichIsA("Humanoid") or false
local Character = game.Players.LocalPlayer.Character
local speaker = game.Players.LocalPlayer
local NOWW = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed
local NOWJ = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").JumpPower
local NOWG = game.Workspace.Gravity
local NOWH = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").HipHeight
local plr = game.Players.LocalPlayer
local playerlp = plr
local Characterlp = plr.Character
local char = plr.Character
local placeId = game.PlaceId
local placeInfo = game:GetService("MarketplaceService"):GetProductInfo(placeId)
local placeName = placeInfo.Name
IYMouse = Players.LocalPlayer:GetMouse()
local genesis_supported = game:FindFirstChildOfClass("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid").BreakJointsOnDeath
if genesis_supported == true then
    genesis_supported = "Hat Scripts will work on this game! :)"
else
    genesis_supported = "Hat Scripts will sadly not work on this game :("
end
local genesis_hats
if game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Unloaded head") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Extra Right hand (Blocky)_white") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Extra Left hand (Blocky)_white") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Front") or game:GetService("Players").LocalPlayer.Character:FindFirstChild("Black") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("LARM") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("RARM") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Unloaded head") then
    genesis_hats = "Wearing Paid Hats."
elseif game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") then
    genesis_hats = "Wearing Free Hats."
else
    genesis_hats = "Not wearing any supported hats, please go to the genesis game and go get them."
end

--[[ STATES ]]--

local HoldingM2 = false
local Active = false
local Lock = false
autoclicking = false
local WalkTo = false
local Guarding = false
local Flinging = false
local Platformstand = false
local Control = false
local Lagging = false
local AutoObby = false
local invisRunning = false
local IsInvis = false
local IsRunning = true
simRadius = false
FLYING = false
QEfly = true
local invisRunning = false
local YesRefresh = false
local NormalSpin = true
local EditingPos = false
local Clicked = true
_G.Spam = false
view = false
anniblockspam = false
control = false
FakeLag = false
Loopvoid = false
Loopkill = false
Loopbring = false
Loopbanish = false
Loopvoid = false 
Loopcuff = false
loopgrab = false
Loopstand = false
Looptornado = false
Loopmute = false
Loopglitch = false
Watch = false
local Clip = true
local Regulars = false

--[[ MISCELLANEOUS  ]]--

iyflyspeed = 1
local epitaph = .187
local CFspeed = 50
local CF
local noclipping
local cfLoop
local simRadLoop
local stareLoop
local currentToolSize = ""
local currentGripPos = ""
local noSit
local noSitDied
local proxDied
local clickDied
local selClick
local selTouch
local selProx
local selSeat
local selInvisp
local selCanc
local invisFix
local invisDied
local invisibleCharacter
local viewDied
local viewChanged
local triggerMd
local triggerMp
local cancelAutoClick
local highlight
local highlight2
local closestTouch
local closestClick
local closestProx
local closestSeat
local lockCursorMan
local unlockCursorMan
local fakeKickTbl

--[[ Table STORAGE ]]--



local flingTbl = {}
local frozenParts = {}
local vfreeze = {}
local restoreCFling = {}
local shownParts = {}
local shownInParts = {}
local shownInvParts = {}
local shownVisParts = {}
local vstrongParts = {}
local vweakParts = {}
local highlights = {}
local humanModCons = {}

--[[ MORE VALUABLES ]]--
local invisRunning = false
local IsInvis = false
local IsRunning = true
local invisFix
local invisDied
local InvisibleCharacter
CFloop = nil

--[[ PLAYER FUNCTIONS ]]--

function getRoot(char)
 local rootPart = game.Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart') or game.Players.LocalPlayer.Character:FindFirstChild('Torso') or game.Players.LocalPlayer.Character:FindFirstChild('UpperTorso')
 return rootPart
end

function r15(plr)
   if game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').RigType == Enum.HumanoidRigType.R15 then
     return true
   end
end

--[[ FUNCTION ]]--
simRadius = false
local simRadLoop
-- Define variables if not already defined
local sethidden = sethiddenproperty or set_hidden_property or set_hidden_prop
local setsimulation = setsimulationradius or set_simulation_radius

function SimRad()
    if sethidden then
        simRadLoop = RunService.Stepped:Connect(function()
            if setsimulation then
                setsimulation(1e308, 1/0)
            else
                sethidden(plr, "MaximumSimulationRadius", 1/0)
                sethidden(plr, "SimulationRadius", 1e308)
            end
        end)
        simRadius = true
    end
end


local function randomString()
    local length = 10 -- adjust this length as needed
    local charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    local result = ""
    for i = 1, length do
        local rand = math.random(1, #charset)
        result = result .. charset:sub(rand, rand)
    end
    return result
end

function Noclip()
 Clip = false
function NoclipLoop()
  if Clip == false and plr.Character ~= nil then
    for _, child in pairs(plr.Character:GetDescendants()) do
      if child:IsA("BasePart") and child.CanCollide == true then
        child.CanCollide = false
      end
    end
  end
end
Noclipping = game:GetService('RunService').Stepped:connect(NoclipLoop)
end

local function GetCharacter(Player)
	if Player.Character then
		return Player.Character
	end
end

local function GetRoot(Player)
	if GetCharacter(Player):FindFirstChild("HumanoidRootPart") then
		return GetCharacter(Player).HumanoidRootPart
	end
end



function getTorso(x)
	 x = x or game.Players.LocalPlayer.Character
	 return x:FindFirstChild("Torso") or x:FindFirstChild("UpperTorso") or x:FindFirstChild("LowerTorso") or x:FindFirstChild("HumanoidRootPart")
 end

local SkidFling = function(TargetPlayer)
	local Character = Player.Character
	local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
	local RootPart = Humanoid and Humanoid.RootPart
 
	local TCharacter = TargetPlayer.Character
	local THumanoid
	local TRootPart
	local THead
	local Accessory
	local Handle
 
	if TCharacter:FindFirstChildOfClass("Humanoid") then
		THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
	end
	if THumanoid and THumanoid.RootPart then
		TRootPart = THumanoid.RootPart
	end
	if TCharacter:FindFirstChild("Head") then
		THead = TCharacter.Head
	end
	if TCharacter:FindFirstChildOfClass("Accessory") then
		Accessory = TCharacter:FindFirstChildOfClass("Accessory")
	end
	if Accessoy and Accessory:FindFirstChild("Handle") then
		Handle = Accessory.Handle
	end
 
	if Character and Humanoid and RootPart then
		if RootPart.Velocity.Magnitude < 50 then
			getgenv().OldPos = RootPart.CFrame
		end
		if THumanoid and THumanoid.Sit and not AllBool then
		end
		if THead then
			workspace.CurrentCamera.CameraSubject = THead
		elseif not THead and Handle then
			workspace.CurrentCamera.CameraSubject = Handle
		elseif THumanoid and TRootPart then
			workspace.CurrentCamera.CameraSubject = THumanoid
		end
		if not TCharacter:FindFirstChildWhichIsA("BasePart") then
			return
		end
		
		local FPos = function(BasePart, Pos, Ang)
			RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
			Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
			RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
			RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
		end
		
		local SFBasePart = function(BasePart)
			local TimeToWait = 2
			local Time = tick()
			local Angle = 0
 
			repeat
				if RootPart and THumanoid then
					if BasePart.Velocity.Magnitude < 50 then
						Angle = Angle + 100
 
						FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
					else
						FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
						
						FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
						task.wait()
					end
				else
					break
				end
			until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
		end
		
		workspace.FallenPartsDestroyHeight = 0/0
		
		local BV = Instance.new("BodyVelocity")
		BV.Name = "EpixVel"
		BV.Parent = RootPart
		BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
		BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
		
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
		
		if TRootPart and THead then
			if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
				SFBasePart(THead)
			else
				SFBasePart(TRootPart)
			end
		elseif TRootPart and not THead then
			SFBasePart(TRootPart)
		elseif not TRootPart and THead then
			SFBasePart(THead)
		elseif not TRootPart and not THead and Accessory and Handle then
			SFBasePart(Handle)
		else
		end
		
		BV:Destroy()
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
		workspace.CurrentCamera.CameraSubject = Humanoid
		
		repeat
			RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
			Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
			Humanoid:ChangeState("GettingUp")
			table.foreach(Character:GetChildren(), function(_, x)
				if x:IsA("BasePart") then
					x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
				end
			end)
			task.wait()
		until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
		workspace.FallenPartsDestroyHeight = getgenv().FPDH
	else
	end
 end



local Target
local KillConnection -- Store the connection for toggling on/off
local NotificationSent = false -- Track if the notification has been sent

local players = {}
local Target = nil

-- Function to update the players list
local function UpdatePlayers()
    players = {}
    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
        table.insert(players, v.DisplayName .. " (" .. v.Name .. ")")
    end
end

-- Initial population of the players list
UpdatePlayers()

local Player = Window:MakeTab({
Name = "Troll",
Icon = "rbxassetid://6034281935",
PremiumOnly = false
})

-- Dropdown for selecting a player
local PlayerDropdown = Player:AddDropdown({
    Name = "Select Player",
    Default = "Select Player",
    Options = players, -- Initial options
    Callback = function(selected)
        Target = selected
    end    
})

-- Function to refresh the dropdown options
local function RefreshDropdown()
    UpdatePlayers()
    PlayerDropdown:Refresh(players, true) -- Refresh the dropdown with updated players list
end

-- Update players list when a player is added
game:GetService("Players").PlayerAdded:Connect(function()
    RefreshDropdown()
end)

-- Update players list when a player is removed
game:GetService("Players").PlayerRemoving:Connect(function(player)
    -- Notify if the selected player leaves
    if Target and player and string.find(Target, player.Name) then
        OrionLib:MakeNotification({
            Name = "Warning",
            Content = player.DisplayName .. " (" .. player.Name .. ") has left the game!",
            Image = "rbxassetid://6031075938",  
            Time = 5
        })
    end
    RefreshDropdown()
end)

-- Click At Target functionality
Player:AddButton({
	Name = "Click At Target",
	Callback = function()
        -- Create the Tool
        local GetTargetTool = Instance.new("Tool")
        GetTargetTool.Name = "ClickTarget"
        GetTargetTool.RequiresHandle = false
        GetTargetTool.ToolTip = "Select A Target"

        -- Function to activate the tool
        local function ActivateTool()
            local player = game.Players.LocalPlayer
            local mouse = player:GetMouse()
            local hit = mouse.Target

            if hit then
                local character = hit.Parent
                local person = game.Players:GetPlayerFromCharacter(character)

                if person then
                    -- Update the Target and dropdown selection
                    Target = person.DisplayName .. " (" .. person.Name .. ")"
                    
                    -- Update the dropdown to reflect the new selection
                    PlayerDropdown:Set(Target)
                    
                    -- Notify the player
                    OrionLib:MakeNotification({
                        Name = "Target Selected",
                        Content = "Selected Target: " .. person.DisplayName,
                        Image = "rbxassetid://6031075938",
                        Time = 5
                    })
                else
                    
                end
            end
        end

        -- Tool activation event
        GetTargetTool.Activated:Connect(ActivateTool)

        -- Adding the Tool to LocalPlayer's Backpack
        local plr = game.Players.LocalPlayer
        GetTargetTool.Parent = plr.Backpack
    end    
})

-- Information button functionality
Player:AddButton({
    Name = "Information",
    Callback = function()
        local playerName = string.match(Target, "%(([^)]+)%)")
        local playerTarget = game.Players:FindFirstChild(playerName)

        if playerTarget and playerTarget.Character and playerTarget.Character:FindFirstChildOfClass('Humanoid') then
            OrionLib:MakeNotification({
                Name = "Information about Player:",
                Content = 'Name: ' .. playerTarget.Name ..
                          ' | Character Name: ' .. playerTarget.Character.Name ..
                          ' | DisplayName: ' .. playerTarget.DisplayName ..
                          ' | Account Age: ' .. playerTarget.AccountAge ..
                          ' | User ID: ' .. playerTarget.UserId ..
                          ' | Health: ' .. math.round(playerTarget.Character:FindFirstChildOfClass('Humanoid').Health, 1) ..
                          ' | WalkSpeed: ' .. playerTarget.Character:FindFirstChildOfClass("Humanoid").WalkSpeed ..
                          ' | JumpPower: ' .. playerTarget.Character:FindFirstChildOfClass("Humanoid").JumpPower,
                Image = "",
                Time = 10
            })
        end
    end
})


local Velocity_Asset = Instance.new("BodyAngularVelocity")
Velocity_Asset.AngularVelocity = Vector3.new(0, 0, 0)
Velocity_Asset.MaxTorque = Vector3.new(50000, 50000, 50000)
Velocity_Asset.P = 1250
Velocity_Asset.Name = "BreakVelocity"



Player:AddButton({
  Name = "Teleport",
  Callback = function()
      local playerName = string.match(Target, "%(([^)]+)%)")


      local targetPlayer = game.Players:FindFirstChild(playerName)
          game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame

      end
})


Player:AddButton({
  Name = "Tween Teleport",
  Callback = function()
      local playerName = string.match(Target, "%(([^)]+)%)")
      local targetPlayer = game.Players:FindFirstChild(playerName)

          local char = game.Players.LocalPlayer
          local targetHRP = targetPlayer.Character.HumanoidRootPart

          local tween = TweenService:Create(char.Character.HumanoidRootPart, TweenInfo.new(2, Enum.EasingStyle.Linear), {CFrame = targetHRP.CFrame + Vector3.new(3, 1, 0)})
          tween:Play()
  end
})




Player:AddToggle({
    Name = "FE Kill",
    Default = false,
    Callback = function(state)
        if state then
            local player = game:GetService("Players").LocalPlayer
            NotificationSent = false -- Reset the flag when the toggle is activated

            -- Ensure only one task is running
            if KillConnection then
                KillConnection:Disconnect()
                KillConnection = nil
            end

            KillConnection = game:GetService("RunService").RenderStepped:Connect(function()
                if not Target then return end

                -- Extract player name from the dropdown selection
                local playerName = string.match(Target, "%(([^)]+)%)")
                local PlayerTarget = game.Players:FindFirstChild(playerName)
                local Char = player.Character
                local Tool = Char and Char:FindFirstChildWhichIsA("Tool")
                local Handle = Tool and Tool:FindFirstChild("Handle")

                -- Ensure that the tool has a handle and is capable of dealing damage
                if Tool and Handle and PlayerTarget and PlayerTarget.Character then
                    local Human = PlayerTarget.Character:FindFirstChildWhichIsA("Humanoid")
                    if not Human or Human.Health <= 0 then
                        if not NotificationSent then
                            OrionLib:MakeNotification({
                                Name = "Warning",
                                Content = "Target player is already dead or left.",
                                Image = "rbxassetid://6031075938", -- Checkmark icon
                                Time = 5
                            })
                            NotificationSent = true
                        end
                        return
                    end

                    -- Spawn a loop to fire touch interest events with the handle
                    task.spawn(function()
                        while Tool and Char and PlayerTarget.Character and Tool.Parent == Char do
                            for _, v in ipairs(PlayerTarget.Character:GetChildren()) do
                                if v:IsA("BasePart") then
                                Tool:Activate()
                                    firetouchinterest(Handle, v, 0)
                                    firetouchinterest(Handle, v, 1)
                                end
                            end
                            task.wait(0.1) -- Control the loop speed
                        end
                    end)
                else
                    -- Show the notification only once if not already sent
                    if not NotificationSent then
                        OrionLib:MakeNotification({
                            Name = "Warning",
                            Content = "You need a tool that can deal damage.",
                            Image = "rbxassetid://6031075938", -- Checkmark icon
                            Time = 5
                        })
                        NotificationSent = true -- Mark the notification as sent
                    end
                end
            end)
        else
            -- Disconnect the loop when the toggle is switched off
            if KillConnection then
                KillConnection:Disconnect()
                KillConnection = nil
            end
        end
    end    
})

Player:AddToggle({
    Name = "FE Kill All",
    Default = false,
    Callback = function(state)
        if state then
            NotificationSent = false -- Reset the flag when the toggle is activated

            -- Ensure only one task is running
            if KillAllConnection then
                KillAllConnection:Disconnect()
                KillAllConnection = nil
            end

            KillAllConnection = game:GetService("RunService").RenderStepped:Connect(function()
                local Char = plr.Character
                local Tool = Char and Char:FindFirstChildWhichIsA("Tool")
                local Handle = Tool and Tool:FindFirstChild("Handle")

                -- Ensure that the tool has a handle and is capable of dealing damage
                if Tool and Handle then
                    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
                        -- Skip the local player
                        if otherPlayer ~= plr and otherPlayer.Character then
                            local Human = otherPlayer.Character:FindFirstChildWhichIsA("Humanoid")
                            if Human and Human.Health > 0 then
                                -- Fire touch interest events with the handle for each player part
                                task.spawn(function()
                                    for _, part in ipairs(otherPlayer.Character:GetChildren()) do
                                        if part:IsA("BasePart") then
                                        Tool:Activate()
                                            firetouchinterest(Handle, part, 0)
                                            firetouchinterest(Handle, part, 1)
                                        end
                                    end
                                end)
                            end
                        end
                    end
                else
                    -- Show the notification only once if not already sent
                    if not NotificationSent then
                        OrionLib:MakeNotification({
                            Name = "Warning",
                            Content = "You need a tool that can deal damage.",
                            Image = "rbxassetid://6031075938", -- Checkmark icon
                            Time = 5
                        })
                        NotificationSent = true -- Mark the notification as sent
                    end
                end
            end)
        else
            -- Disconnect the loop when the toggle is switched off
            if KillAllConnection then
                KillAllConnection:Disconnect()
                KillAllConnection = nil
            end
        end
    end    
})

Player:AddButton({
	Name = "Tp UnAnchored Parts to Player",
	Callback = function()
      	if sethidden then
			local Forces = {}
			for _,part in pairs(game.Workspace:GetDescendants()) do
				if PlayerTarget.Character:FindFirstChild("Head") and part:IsA("BasePart" or "UnionOperation" or "Model") and part.Anchored == false and not part:IsDescendantOf(plr.Character) and part.Name == "Torso" == false and part.Name == "Head" == false and part.Name == "Right Arm" == false and part.Name == "Left Arm" == false and part.Name == "Right Leg" == false and part.Name == "Left Leg" == false and part.Name == "HumanoidRootPart" == false then
					for i,c in pairs(part:GetChildren()) do
						if c:IsA("BodyPosition") or c:IsA("BodyGyro") then
							c:Destroy()
						end
					end
					local ForceInstance = Instance.new("BodyPosition")
					ForceInstance.Parent = part
					ForceInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
					table.insert(Forces, ForceInstance)
					if not table.find(frozenParts,part) then
						table.insert(frozenParts,part)
					end
				end
			end
			if not simRadius then
				SimRad()
			end
			for i,c in pairs(Forces) do
				c.Position = PlayerTarget.Character.Head.Position
			end
		end
	end    
})


Player:AddButton({
	Name = "Fling",
	Callback = function()
	local playerName = string.match(Target, "%(([^)]+)%)")
 local Target = game.Players:FindFirstChild(playerName)
      	SkidFling(Target)
  	end    
})

Player:AddToggle({
     Name = "Loop Fling",
     Default = false,
     Callback = function(state)
 if state == true then
                local playerName = string.match(Target, "%(([^)]+)%)")
 local Targets = game.Players:FindFirstChild(playerName)

      Loopvoid = true
      repeat wait()
  SkidFling(Targets)
      until Loopvoid == false
        else
            Loopvoid = false
        end
    end
 })
 
Player:AddButton({
	Name = "Fling All",
	Callback = function()
       local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= localPlayer then
        SkidFling(player)
    end
end	
  	end    
})

Player:AddToggle({
	Name = "Loop Fling All",
	Default = false,
	Callback = function(state)
if state == true then

      Loopvoid = true
      repeat wait()
  
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= localPlayer then
        SkidFling(player)
    end
end

      until Loopvoid == false
        else
            Loopvoid = false
        end
  end    
})

Player:AddToggle({
    Name = "Animation Steal Player",
    Default = false,
    Callback = function(animsteals)
        local plr = game.Players.LocalPlayer
        if animsteals then
            local playerName = string.match(Target, "%(([^)]+)%)")
            local PlayerTarget = game.Players:FindFirstChild(playerName)

            -- Check if the player's character is in R15
            if plr.Character.Humanoid.RigType ~= Enum.HumanoidRigType.R15 then
                OrionLib:MakeNotification({
                    Name = "Warning",
                    Content = "You should be R15 to steal animation.",
                    Image = "rbxassetid://6031075938",  -- Checkmark icon
                    Time = 5
                })
                return
            end

            -- Check if the target player's character is in R15
            if PlayerTarget.Character.Humanoid.RigType ~= Enum.HumanoidRigType.R15 then
                OrionLib:MakeNotification({
                    Name = "Warning",
                    Content = "The player you are trying to steal from is in R6. Try choosing another player.",
                    Image = "rbxassetid://6031075938",  -- Checkmark icon
                    Time = 5
                })
                return
            end

            if PlayerTarget.Character:FindFirstChild("Animate") then
                if plr.Character:FindFirstChild("Animate") then
                    local checkifmyanim = plr.Character:FindFirstChild("animstorage")
                    if checkifmyanim then
                        plr.Character:FindFirstChild("Animate"):Destroy()
                        checkifmyanim.Name = "Animate"
                        checkifmyanim.Disabled = false
                    end
                end

                local currentAnimate = plr.Character:FindFirstChild("Animate")
                if currentAnimate then
                    currentAnimate.Name = "animstorage"
                    currentAnimate.Disabled = true
                end

                local newAnim = PlayerTarget.Character.Animate:Clone()
                newAnim.Parent = plr.Character
                newAnim.Name = "Animate"
            end
        else
            -- When toggle is off, restore original animations
            if plr.Character:FindFirstChild("animstorage") then
                if plr.Character:FindFirstChild("Animate") then
                    plr.Character:FindFirstChild("Animate"):Destroy()
                end
                local animStorage = plr.Character:FindFirstChild("animstorage")
                animStorage.Name = "Animate"
                animStorage.Disabled = false
            end
        end
    end
})

-- Declare variables outside the function to maintain state
local viewDied = nil
local viewChanged = nil
local viewing = nil
local plr = game.Players.LocalPlayer

Player:AddToggle({
    Name = "View Player",
    Default = false,
    Callback = function(View)
        if View == true then
            -- Disconnect previous connections if any
            if viewDied then
                viewDied:Disconnect()
                viewDied = nil
            end
            if viewChanged then
                viewChanged:Disconnect()
                viewChanged = nil
            end

            -- Extract the player name from the Target variable
            local playerName = string.match(Target, "%(([^)]+)%)")
            local PlayerTarget = game.Players:FindFirstChild(playerName)

            if PlayerTarget and PlayerTarget.Character then
                -- Set the viewing target
                viewing = PlayerTarget
                game.Workspace.CurrentCamera.CameraSubject = viewing.Character

                -- Function to handle character respawn
                local function viewDiedFunc()
                    repeat wait() until PlayerTarget.Character ~= nil and PlayerTarget.Character:FindFirstChild("HumanoidRootPart")
                    game.Workspace.CurrentCamera.CameraSubject = viewing.Character
                end

                -- Connect character added event
                viewDied = PlayerTarget.CharacterAdded:Connect(viewDiedFunc)

                -- Function to handle camera subject change
                local function viewChangedFunc()
                    game.Workspace.CurrentCamera.CameraSubject = viewing.Character
                end

                -- Connect property changed event
                viewChanged = game.Workspace.CurrentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(viewChangedFunc)
            end
        else
            -- Reset the view
            viewing = nil
            if viewDied then
                viewDied:Disconnect()
                viewDied = nil
            end
            if viewChanged then
                viewChanged:Disconnect()
                viewChanged = nil
            end
            game.Workspace.CurrentCamera.CameraSubject = plr.Character
        end
    end    
})

local RunService = game:GetService("RunService")
local t
local bangLoop
local bangDied
local bang
local bangAnim

Player:AddToggle({
    Name = "Bang",
    Default = false,
    Callback = function(bangState)
        if bangState then
            local speed = t
            if speed == nil then
                speed = 10
            end
local playerName = string.match(Target, "%(([^)]+)%)")

      local Target = game.Players:FindFirstChild(playerName)

            bangAnim = Instance.new("Animation")
            if not r15(game.Players.LocalPlayer) then
                bangAnim.AnimationId = "rbxassetid://148840371"
            else
                bangAnim.AnimationId = "rbxassetid://5918726674"
            end

            bang = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(bangAnim)
            bang:Play(.1, 1, 1)
            bang:AdjustSpeed(speed)

            local bangplr = Target.Name
            bangDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                if bangLoop then bangLoop:Disconnect() end
                bang:Stop()
                bangAnim:Destroy()
                bangDied:Disconnect()
            end)

            local bangOffset = CFrame.new(0, 0, 1.1)
            bangLoop = RunService.Stepped:Connect(function()
                pcall(function()
                    local otherRoot = getTorso(game.Players[bangplr].Character)
                    getRoot(game.Players.LocalPlayer.Character).CFrame = otherRoot.CFrame * bangOffset
                end)
            end)
        else
            if bangLoop then bangLoop:Disconnect() end
            if bang then bang:Stop() end
            if bangAnim then
                bangAnim:Destroy()
                bangAnim = nil -- Ensure the reference is cleared
            end
            if bangDied then bangDied:Disconnect() end
        end
    end
})



Player:AddTextbox({
  Name = "Bang Speed",
  Default = "",
  TextDisappear = true,
  Callback = function(h)
     t = tonumber(h)
  end	  
})

local RunService = game:GetService("RunService")
local bangLoop
local bangDied
local bang
local bangAnim

Player:AddToggle({
    Name = "Headbang",
    Default = false,
    Callback = function(Bang)
        if Bang then
            local speed = d

            if speed == nil then
                speed = 10
            end

local playerName = string.match(Target, "%(([^)]+)%)")

      local players = game.Players:FindFirstChild(playerName)


            bangAnim = Instance.new("Animation")
            if not r15(game.Players.LocalPlayer) then
                bangAnim.AnimationId = "rbxassetid://148840371"
            else
                bangAnim.AnimationId = "rbxassetid://5918726674"
            end

            bang = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(bangAnim)
            bang:Play(.1, 1, 1)
            bang:AdjustSpeed(speed)

            local bangplr = players.Name
            bangDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                if bangLoop then bangLoop:Disconnect() end
                if bang then bang:Stop() end
                if bangAnim then bangAnim:Destroy() end
                if bangDied then bangDied:Disconnect() end
            end)

            local bangOffset = CFrame.new(0, 1, -1.1)
            bangLoop = RunService.Stepped:Connect(function()
                pcall(function()
                    local otherRoot = game.Players[bangplr].Character:FindFirstChild("Head")
                    if otherRoot then
                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = otherRoot.CFrame * bangOffset
                        local CharPos = game.Players.LocalPlayer.Character.PrimaryPart.Position
                        local tpos = players.Character:FindFirstChild("HumanoidRootPart").Position
                        local TPos = Vector3.new(tpos.X, CharPos.Y, tpos.Z)
                        local NewCFrame = CFrame.new(CharPos, TPos)
                        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(NewCFrame)
                    end
                end)
            end)
        else
            if bangLoop then bangLoop:Disconnect() end
            if bang then bang:Stop() end
            if bangAnim then
                bangAnim:Destroy()
                bangAnim = nil -- Clear reference
            end
            if bangDied then bangDied:Disconnect() end
        end
    end
})




Player:AddTextbox({
  Name = "Headbang Speed ",
  Default = "",
  TextDisappear = true,
  Callback = function(h)
     d = tonumber(h)
  end	  
})

local headSit
local sitLoop
local sitDied

Player:AddToggle({
    Name = "Head Stand",
    Default = false,
    Callback = function(stand)
        if stand then
            if headSit then headSit:Disconnect() end

local playerName = string.match(Target, "%(([^)]+)%)")

      local players = game.Players:FindFirstChild(playerName)


            local sitPlr = players.Name

            sitDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                if sitLoop then sitLoop:Disconnect() end
                if headSit then headSit:Disconnect() end
            end)

            headSit = RunService.Heartbeat:Connect(function()
                if Players:FindFirstChild(players.Name) and players.Character ~= nil and getRoot(players.Character) and getRoot(game.Players.LocalPlayer.Character) then
                    getRoot(game.Players.LocalPlayer.Character).CFrame = players.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(0), 0) * CFrame.new(0, 4.6, 0.4)
                else
                    if headSit then headSit:Disconnect() end
                end
            end)
        else
            if headSit then headSit:Disconnect() end
            if sitDied then sitDied:Disconnect() end
        end
    end
})


Player:AddToggle({
  Name = "Head Sit",
  Default = false,
  Callback = function(state)
    if state == true then
        if headSit then 
            headSit:Disconnect()
        end

        local playerName = string.match(Target, "%(([^)]+)%)")
        local players = game.Players:FindFirstChild(playerName)
        if players and players.Character then
            local sitPlr = players.Name

            sitDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                if sitLoop then
                    sitLoop:Disconnect()
                end
            end)

            game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Sit = true

            headSit = RunService.Heartbeat:Connect(function()
                if game.Players:FindFirstChild(players.Name) 
                and players.Character 
                and getRoot(players.Character) 
                and getRoot(game.Players.LocalPlayer.Character) 
                and game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Sit == true then
                    getRoot(game.Players.LocalPlayer.Character).CFrame = players.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(0), 0) * CFrame.new(0, 1.6, 0.4)
                else
                    headSit:Disconnect()
                end
            end)
        end
    else
        if headSit then 
            headSit:Disconnect()
        end

        -- Avoid forcing jump when the toggle is turned off, just ensure not sitting
        local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        if humanoid and humanoid.Sit then
            humanoid.Sit = false -- Ensure the player is no longer sitting
        end
    end
  end    
})

local plr = game.Players.LocalPlayer
local WalkTo = false

local function getRoot(character)
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("LowerTorso")
end

local function getTargetPlayer()
    if not Target then
        return nil
    end
    local playerName = string.match(Target, "%(([^)]+)%)")
    return game.Players:FindFirstChild(playerName)
end

Player:AddToggle({
    Name = "Walk To",
    Default = false,
    Callback = function(Walkn)
        if Walkn then
            local target = getTargetPlayer()
            if not target or not target.Character then
                warn("Target player not found or does not have a character.")
                return
            end

            local humanoid = plr.Character:FindFirstChildOfClass('Humanoid')
            if humanoid and humanoid.SeatPart then
                humanoid.Sit = false
                wait(0.1)
            end

            if not WalkTo then
                WalkTo = true
                while WalkTo do
                    wait()
                    local targetRoot = getRoot(target.Character)
                    if targetRoot then
                        humanoid:MoveTo(targetRoot.Position)
                    else
                        WalkTo = false
                    end

                    -- Exit loop if target is invalid
                    if not target.Character or not getRoot(target.Character) then
                        WalkTo = false
                    end
                end
            end
        else
            WalkTo = false
        end
    end    
})

Player:AddToggle({
    Name = "Pathfind Walk To",
    Default = false,
    Callback = function(Walkns)
        if Walkns then
            WalkTo = false -- Ensure the first toggle stops walking
            local target = getTargetPlayer()
            if not target or not target.Character then
                warn("Target player not found or does not have a character.")
                return
            end

            local PathService = game:GetService("PathfindingService")
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            if not humanoid then
                warn("Humanoid not found in player's character.")
                return
            end

            local path = PathService:CreatePath({
                AgentRadius = 2,
                AgentHeight = 5,
                AgentCanJump = true,
                AgentWalksOnWater = true,
            })

            local function computePath()
                local startPos = getRoot(plr.Character).Position
                local endPos = getRoot(target.Character).Position
                path:ComputeAsync(startPos, endPos)
                return path
            end

            if not WalkTo then
                WalkTo = true
                while WalkTo do
                    wait()
                    local success, result = pcall(computePath)
                    if success then
                        local waypoints = path:GetWaypoints()
                        for _, waypoint in ipairs(waypoints) do
                            if not WalkTo then break end
                            humanoid:MoveTo(waypoint.Position)
                            humanoid.MoveToFinished:Wait()
                            if waypoint.Action == Enum.PathWaypointAction.Jump then
                                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                            end
                        end
                    else
                        -- Fallback to simple MoveTo if pathfinding fails
                        humanoid:MoveTo(getRoot(target.Character).Position)
                    end

                    -- Exit loop if target is invalid
                    if not target.Character or not getRoot(target.Character) then
                        WalkTo = false
                    end
                end
            end
        else
            WalkTo = false
        end
    end    
})

local Players = game:GetService("Players")
local Staring

Player:AddToggle({
    Name = "Stare",
    Default = false,
    Callback = function(Stare)
        if Stare then
        local playerName = string.match(Target, "%(([^)]+)%)")
            local Target = game.Players:FindFirstChild(playerName)
            if Staring then
                Staring:Disconnect()
            end
            if not Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or not Target.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            local function StareAtTarget()
                if Players.LocalPlayer.Character.PrimaryPart and Players:FindFirstChild(Target.Name) and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
                    local CharPos = Players.LocalPlayer.Character.PrimaryPart.Position
                    local tpos = Target.Character:FindFirstChild("HumanoidRootPart").Position
                    local TPos = Vector3.new(tpos.X, CharPos.Y, tpos.Z)
                    local NewCFrame = CFrame.new(CharPos, TPos)
                    Players.LocalPlayer.Character:SetPrimaryPartCFrame(NewCFrame)
                elseif not Players:FindFirstChild(Target.Name) then
                    Staring:Disconnect()
                end
            end

            Staring = game:GetService("RunService").RenderStepped:Connect(StareAtTarget)
        else
            if Staring then
                Staring:Disconnect()
            end
        end
    end    
})

end
