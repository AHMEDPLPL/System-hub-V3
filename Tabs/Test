return function(Window, OrionLib)

local Area = game:GetService("Workspace")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local StarterGui = game:GetService("StarterGui")

--[[ VARIABLES ]]--

local IsOnMobile = table.find({
	Enum.Platform.IOS,
	Enum.Platform.Android
}, UserInputService:GetPlatform())
local player = Players.LocalPlayer
local character = player.Character
local char = character 
local Players = game:GetService("Players")
 local Player = Players.LocalPlayer
 
 local AllBool = false
local Player = game.Players.LocalPlayer
local Humanoid = Character and Character:FindFirstChildWhichIsA("Humanoid") or false
local Character = game.Players.LocalPlayer.Character
local speaker = game.Players.LocalPlayer
local NOWW = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").WalkSpeed
local NOWJ = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").JumpPower
local NOWG = game.Workspace.Gravity
local NOWH = game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid").HipHeight
local plr = game.Players.LocalPlayer
local playerlp = plr
local Characterlp = plr.Character
local char = plr.Character
local placeId = game.PlaceId
local placeInfo = game:GetService("MarketplaceService"):GetProductInfo(placeId)
local placeName = placeInfo.Name
IYMouse = Players.LocalPlayer:GetMouse()
local genesis_supported = game:FindFirstChildOfClass("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid").BreakJointsOnDeath
if genesis_supported == true then
    genesis_supported = "Hat Scripts will work on this game! :)"
else
    genesis_supported = "Hat Scripts will sadly not work on this game :("
end
local genesis_hats
if game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Unloaded head") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Extra Right hand (Blocky)_white") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Extra Left hand (Blocky)_white") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Front") or game:GetService("Players").LocalPlayer.Character:FindFirstChild("Black") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("LARM") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("RARM") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("Unloaded head") then
    genesis_hats = "Wearing Paid Hats."
elseif game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") and game:GetService("Players").LocalPlayer.Character:FindFirstChild("MeshPartAccessory") then
    genesis_hats = "Wearing Free Hats."
else
    genesis_hats = "Not wearing any supported hats, please go to the genesis game and go get them."
end

--[[ STATES ]]--

local invisRunning = false
local IsInvis = false
local IsRunning = true
simRadius = false
FLYING = false
QEfly = true
local invisRunning = false
local Clip = true

--[[ MISCELLANEOUS  ]]--

iyflyspeed = 1
local epitaph = .187
local CFspeed = 50
local CF
local noclipping
local cfLoop
local simRadLoop

--[[ Table STORAGE ]]--



local flingTbl = {}
local frozenParts = {}
local vfreeze = {}

--[[ MORE VALUABLES ]]--
local invisRunning = false
local IsInvis = false
local IsRunning = true
local invisFix
local invisDied
local InvisibleCharacter
CFloop = nil

--[[ PLAYER FUNCTIONS ]]--

function getRoot(char)
 local rootPart = game.Players.LocalPlayer.Character:FindFirstChild('HumanoidRootPart') or game.Players.LocalPlayer.Character:FindFirstChild('Torso') or game.Players.LocalPlayer.Character:FindFirstChild('UpperTorso')
 return rootPart
end

function r15(plr)
   if game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').RigType == Enum.HumanoidRigType.R15 then
     return true
   end
end

--[[ FUNCTION ]]--
simRadius = false
local simRadLoop
-- Define variables if not already defined
local sethidden = sethiddenproperty or set_hidden_property or set_hidden_prop
local setsimulation = setsimulationradius or set_simulation_radius

function SimRad()
    if sethidden then
        simRadLoop = RunService.Stepped:Connect(function()
            if setsimulation then
                setsimulation(1e308, 1/0)
            else
                sethidden(plr, "MaximumSimulationRadius", 1/0)
                sethidden(plr, "SimulationRadius", 1e308)
            end
        end)
        simRadius = true
    end
end


local function randomString()
    local length = 10 -- adjust this length as needed
    local charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    local result = ""
    for i = 1, length do
        local rand = math.random(1, #charset)
        result = result .. charset:sub(rand, rand)
    end
    return result
end

function Noclip()
 Clip = false
function NoclipLoop()
  if Clip == false and plr.Character ~= nil then
    for _, child in pairs(plr.Character:GetDescendants()) do
      if child:IsA("BasePart") and child.CanCollide == true then
        child.CanCollide = false
      end
    end
  end
end
Noclipping = game:GetService('RunService').Stepped:connect(NoclipLoop)
end

local function GetCharacter(Player)
	if Player.Character then
		return Player.Character
	end
end

local function GetRoot(Player)
	if GetCharacter(Player):FindFirstChild("HumanoidRootPart") then
		return GetCharacter(Player).HumanoidRootPart
	end
end

function getTorso(x)
	 x = x or game.Players.LocalPlayer.Character
	 return x:FindFirstChild("Torso") or x:FindFirstChild("UpperTorso") or x:FindFirstChild("LowerTorso") or x:FindFirstChild("HumanoidRootPart")
 end

local SkidFling = function(TargetPlayer)
	local Character = Player.Character
	local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
	local RootPart = Humanoid and Humanoid.RootPart
 
	local TCharacter = TargetPlayer.Character
	local THumanoid
	local TRootPart
	local THead
	local Accessory
	local Handle
 
	if TCharacter:FindFirstChildOfClass("Humanoid") then
		THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
	end
	if THumanoid and THumanoid.RootPart then
		TRootPart = THumanoid.RootPart
	end
	if TCharacter:FindFirstChild("Head") then
		THead = TCharacter.Head
	end
	if TCharacter:FindFirstChildOfClass("Accessory") then
		Accessory = TCharacter:FindFirstChildOfClass("Accessory")
	end
	if Accessoy and Accessory:FindFirstChild("Handle") then
		Handle = Accessory.Handle
	end
 
	if Character and Humanoid and RootPart then
		if RootPart.Velocity.Magnitude < 50 then
			getgenv().OldPos = RootPart.CFrame
		end
		if THumanoid and THumanoid.Sit and not AllBool then
		end
		if THead then
			workspace.CurrentCamera.CameraSubject = THead
		elseif not THead and Handle then
			workspace.CurrentCamera.CameraSubject = Handle
		elseif THumanoid and TRootPart then
			workspace.CurrentCamera.CameraSubject = THumanoid
		end
		if not TCharacter:FindFirstChildWhichIsA("BasePart") then
			return
		end
		
		local FPos = function(BasePart, Pos, Ang)
			RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
			Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
			RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
			RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
		end
		
		local SFBasePart = function(BasePart)
			local TimeToWait = 2
			local Time = tick()
			local Angle = 0
 
			repeat
				if RootPart and THumanoid then
					if BasePart.Velocity.Magnitude < 50 then
						Angle = Angle + 100
 
						FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
						task.wait()
					else
						FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
						
						FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
						task.wait()
 
						FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
						task.wait()
					end
				else
					break
				end
			until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
		end
		
		workspace.FallenPartsDestroyHeight = 0/0
		
		local BV = Instance.new("BodyVelocity")
		BV.Name = "EpixVel"
		BV.Parent = RootPart
		BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
		BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
		
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
		
		if TRootPart and THead then
			if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
				SFBasePart(THead)
			else
				SFBasePart(TRootPart)
			end
		elseif TRootPart and not THead then
			SFBasePart(TRootPart)
		elseif not TRootPart and THead then
			SFBasePart(THead)
		elseif not TRootPart and not THead and Accessory and Handle then
			SFBasePart(Handle)
		else
		end
		
		BV:Destroy()
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
		workspace.CurrentCamera.CameraSubject = Humanoid
		
		repeat
			RootPart.CFrame = getgenv().OldPos * CFrame.new(0, .5, 0)
			Character:SetPrimaryPartCFrame(getgenv().OldPos * CFrame.new(0, .5, 0))
			Humanoid:ChangeState("GettingUp")
			table.foreach(Character:GetChildren(), function(_, x)
				if x:IsA("BasePart") then
					x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
				end
			end)
			task.wait()
		until (RootPart.Position - getgenv().OldPos.p).Magnitude < 25
		workspace.FallenPartsDestroyHeight = getgenv().FPDH
	else
	end
 end

local function TeleportTO(posX,posY,posZ,player,method)
	pcall(function()
		if method == "safe" then
			task.spawn(function()
				for i = 1,30 do
					task.wait()
					GetRoot(plr).Velocity = Vector3.new(0,0,0)
					if player == "pos" then
						GetRoot(plr).CFrame = CFrame.new(posX,posY,posZ)
					else
						GetRoot(plr).CFrame = CFrame.new(GetRoot(player).Position)+Vector3.new(0,2,0)
					end
				end
			end)
		else
			GetRoot(plr).Velocity = Vector3.new(0,0,0)
			if player == "pos" then
				GetRoot(plr).CFrame = CFrame.new(posX,posY,posZ)
			else
				GetRoot(plr).CFrame = CFrame.new(GetRoot(player).Position)+Vector3.new(0,2,0)
			end
		end
	end)
end

local function PredictionTP(player,method)
	local root = GetRoot(player)
	local pos = root.Position
	local vel = root.Velocity
	GetRoot(plr).CFrame = CFrame.new((pos.X)+(vel.X)*(GetPing()*3.5),(pos.Y)+(vel.Y)*(GetPing()*2),(pos.Z)+(vel.Z)*(GetPing()*3.5))
	if method == "safe" then
		task.wait()
		GetRoot(plr).CFrame = CFrame.new(pos)
		task.wait()
		GetRoot(plr).CFrame = CFrame.new((pos.X)+(vel.X)*(GetPing()*3.5),(pos.Y)+(vel.Y)*(GetPing()*2),(pos.Z)+(vel.Z)*(GetPing()*3.5))
	end
end

local function PlayAnim(id,time,speed)
	pcall(function()
		plr.Character.Animate.Disabled = false
		local hum = plr.Character.Humanoid
		local animtrack = hum:GetPlayingAnimationTracks()
		for i,track in pairs(animtrack) do
			track:Stop()
		end
		plr.Character.Animate.Disabled = true
		local Anim = Instance.new("Animation")
		Anim.AnimationId = "rbxassetid://"..id
		local loadanim = hum:LoadAnimation(Anim)
		loadanim:Play()
		loadanim.TimePosition = time
		loadanim:AdjustSpeed(speed)
		loadanim.Stopped:Connect(function()
			plr.Character.Animate.Disabled = false
			for i, track in pairs (animtrack) do
        		track:Stop()
    		end
		end)
	end)
end

local function StopAnim()
	plr.Character.Animate.Disabled = false
    local animtrack = plr.Character.Humanoid:GetPlayingAnimationTracks()
    for i, track in pairs (animtrack) do
        track:Stop()
    end
end

function TurnsVisible()
  if IsInvis == false then return end
  invisFix:Disconnect()
  invisDied:Disconnect()
  CF = game.Workspace.CurrentCamera.CFrame
  Characterlp = Characterlp
  local CF_1 = playerlp.Character.HumanoidRootPart.CFrame
  Characterlp.HumanoidRootPart.CFrame = CF_1
  InvisibleCharacter:Destroy()
  playerlp.Character = Characterlp
  Characterlp.Parent = workspace
  IsInvis = false
  playerlp.Character.Animate.Disabled = true
  playerlp.Character.Animate.Disabled = false
  invisDied = Characterlp:FindFirstChildOfClass'Humanoid'.Died:Connect(function()
    invisRespawn()
    invisDied:Disconnect()
  end)
  invisRunning = false
end

function invisRespawn()
  IsRunning = false
  if IsInvis == true then
    pcall(function()
      playerlp.Character = Characterlp
      wait()
      Characterlp.Parent = game.Workspace
      Characterlp:FindFirstChildWhichIsA'Humanoid':Destroy()
      IsInvis = false
      InvisibleCharacter.Parent = nil
      invisRunning = false
    end)
  elseif IsInvis == false then
    pcall(function()
      playerlp.Character = Characterlp
      wait()
      Characterlp.Parent = game.Workspace
      Characterlp:FindFirstChildWhichIsA'Humanoid':Destroy()
      TurnsVisible()
    end)
  end
end

function TurnVisible()
  if IsInvis == false then return end
  invisFix:Disconnect()
  invisDied:Disconnect()
  CF = game.Workspace.CurrentCamera.CFrame
  Characterlp = Characterlp
  local CF_1 = playerlp.Character.HumanoidRootPart.CFrame
  Characterlp.HumanoidRootPart.CFrame = CF_1
  InvisibleCharacter:Destroy()
  playerlp.Character = Characterlp
  Characterlp.Parent = workspace
  IsInvis = false
  playerlp.Character.Animate.Disabled = true
  playerlp.Character.Animate.Disabled = false
  invisDied = Characterlp:FindFirstChildOfClass'Humanoid'.Died:Connect(function()
    invisRespawn()
    invisDied:Disconnect()
  end)
  invisRunning = false
end

function fixcam()
   game.Workspace.CurrentCamera:Remove()
	wait(.1)
	repeat wait() until plr.Character ~= nil
	game.Workspace.CurrentCamera.CameraSubject = plr.Character:FindFirstChildWhichIsA('Humanoid')
	game.Workspace.CurrentCamera.CameraType = "Custom"
	plr.CameraMinZoomDistance = 0.5
	plr.CameraMaxZoomDistance = 400
	plr.CameraMode = "Classic"
	plr.Character.Head.Anchored = false
end




local function align(part0,part1)
local attachment0 = Instance.new("Attachment",part1)
local attachment1 = Instance.new("Attachment",part0)

local alignpos = Instance.new("AlignPosition",part0)
alignpos.MaxForce = math.huge
alignpos.Responsiveness = 200
alignpos.Attachment0 = attachment0
alignpos.Attachment1 = attachment1
end

local function fling(part0)
local vel = Instance.new("BodyAngularVelocity",part0)
vel.AngularVelocity = Vector3.new(1,1,1)*999
vel.MaxTorque = Vector3.new(1,1,1)*9999
end

local function loadcharacter(character)
local scf = character.HumanoidRootPart.CFrame
character.HumanoidRootPart.CFrame = scf*CFrame.new(0,100,0)
character.HumanoidRootPart.Anchored = true

wait(1)

local fakec = Instance.new("Model",workspace)

local froot = Instance.new("Part",fakec)
froot.Name = "HumanoidRootPart"
froot.Size = Vector3.new(1,5,1)
froot.CFrame = scf
froot.Transparency = 0.5

Instance.new("Humanoid",fakec)

plr.Character = fakec
workspace.CurrentCamera.CameraSubject = fakec.Humanoid

align(froot,character.HumanoidRootPart)

character.Humanoid:Destroy()

for _,p in pairs(character:GetDescendants()) do
  if p:IsA("BasePart") then
    p.CanCollide = false
    p.Massless = true
  elseif p:IsA("BodyGyro") or p:IsA("BodyAngularVelocity") or p:IsA("BodyVelocity") then
    p:Destroy()
  end
end

game.RunService.Heartbeat:Connect(function()
  for _,p in pairs(character:GetDescendants()) do
  if p:IsA("BasePart") then
    p.CanCollide = false
    p.Massless = true
    p.Anchored = false
  elseif p:IsA("Weld")then
    p.Enabled = false
  end
end
end)


wait()

wait(1)
fling(character.HumanoidRootPart)
end


FLYING = false
QEfly = true
iyflyspeed = 1
vehicleflyspeed = 1
function sFLY(vfly)
	repeat wait() until Players.LocalPlayer and Players.LocalPlayer.Character and getRoot(Players.LocalPlayer.Character) and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	repeat wait() until IYMouse
	if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end

	local T = getRoot(Players.LocalPlayer.Character)
	local CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
	local lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
	local SPEED = 0

	local function FLY()
		FLYING = true
		local BG = Instance.new('BodyGyro')
		local BV = Instance.new('BodyVelocity')
		BG.P = 9e4
		BG.Parent = T
		BV.Parent = T
		BG.maxTorque = Vector3.new(9e9, 9e9, 9e9)
		BG.cframe = T.CFrame
		BV.velocity = Vector3.new(0, 0, 0)
		BV.maxForce = Vector3.new(9e9, 9e9, 9e9)
		task.spawn(function()
			repeat wait()
				if not vfly and Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
					Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
				end
				if CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0 then
					SPEED = 50
				elseif not (CONTROL.L + CONTROL.R ~= 0 or CONTROL.F + CONTROL.B ~= 0 or CONTROL.Q + CONTROL.E ~= 0) and SPEED ~= 0 then
					SPEED = 0
				end
				if (CONTROL.L + CONTROL.R) ~= 0 or (CONTROL.F + CONTROL.B) ~= 0 or (CONTROL.Q + CONTROL.E) ~= 0 then
					BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (CONTROL.F + CONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(CONTROL.L + CONTROL.R, (CONTROL.F + CONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
					lCONTROL = {F = CONTROL.F, B = CONTROL.B, L = CONTROL.L, R = CONTROL.R}
				elseif (CONTROL.L + CONTROL.R) == 0 and (CONTROL.F + CONTROL.B) == 0 and (CONTROL.Q + CONTROL.E) == 0 and SPEED ~= 0 then
					BV.velocity = ((workspace.CurrentCamera.CoordinateFrame.lookVector * (lCONTROL.F + lCONTROL.B)) + ((workspace.CurrentCamera.CoordinateFrame * CFrame.new(lCONTROL.L + lCONTROL.R, (lCONTROL.F + lCONTROL.B + CONTROL.Q + CONTROL.E) * 0.2, 0).p) - workspace.CurrentCamera.CoordinateFrame.p)) * SPEED
				else
					BV.velocity = Vector3.new(0, 0, 0)
				end
				BG.cframe = workspace.CurrentCamera.CoordinateFrame
			until not FLYING
			CONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
			lCONTROL = {F = 0, B = 0, L = 0, R = 0, Q = 0, E = 0}
			SPEED = 0
			BG:Destroy()
			BV:Destroy()
			if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
				Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
			end
		end)
	end
	flyKeyDown = IYMouse.KeyDown:Connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = (vfly and vehicleflyspeed or iyflyspeed)
		elseif KEY:lower() == 's' then
			CONTROL.B = - (vfly and vehicleflyspeed or iyflyspeed)
		elseif KEY:lower() == 'a' then
			CONTROL.L = - (vfly and vehicleflyspeed or iyflyspeed)
		elseif KEY:lower() == 'd' then 
			CONTROL.R = (vfly and vehicleflyspeed or iyflyspeed)
		elseif QEfly and KEY:lower() == 'e' then
			CONTROL.Q = (vfly and vehicleflyspeed or iyflyspeed)*2
		elseif QEfly and KEY:lower() == 'q' then
			CONTROL.E = -(vfly and vehicleflyspeed or iyflyspeed)*2
		end
		pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Track end)
	end)
	flyKeyUp = IYMouse.KeyUp:Connect(function(KEY)
		if KEY:lower() == 'w' then
			CONTROL.F = 0
		elseif KEY:lower() == 's' then
			CONTROL.B = 0
		elseif KEY:lower() == 'a' then
			CONTROL.L = 0
		elseif KEY:lower() == 'd' then
			CONTROL.R = 0
		elseif KEY:lower() == 'e' then
			CONTROL.Q = 0
		elseif KEY:lower() == 'q' then
			CONTROL.E = 0
		end
	end)
	FLY()
end

function NOFLY()
	FLYING = false
	if flyKeyDown or flyKeyUp then flyKeyDown:Disconnect() flyKeyUp:Disconnect() end
	if Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid') then
		Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
	end
	pcall(function() workspace.CurrentCamera.CameraType = Enum.CameraType.Custom end)
end

local velocityHandlerName = randomString()
local gyroHandlerName = randomString()
local mfly1
local mfly2

local unmobilefly = function(speaker)
	pcall(function()
		FLYING = false
		local root = getRoot(speaker.Character)
		root:FindFirstChild(velocityHandlerName):Destroy()
		root:FindFirstChild(gyroHandlerName):Destroy()
		speaker.Character:FindFirstChildWhichIsA("Humanoid").PlatformStand = false
		mfly1:Disconnect()
		mfly2:Disconnect()
	end)
end

local mobilefly = function(speaker, vfly)
	unmobilefly(speaker)
	FLYING = true

	local root = getRoot(speaker.Character)
	local camera = workspace.CurrentCamera
	local v3none = Vector3.new()
	local v3zero = Vector3.new(0, 0, 0)
	local v3inf = Vector3.new(9e9, 9e9, 9e9)

	local controlModule = require(speaker.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))
	local bv = Instance.new("BodyVelocity")
	bv.Name = velocityHandlerName
	bv.Parent = root
	bv.MaxForce = v3zero
	bv.Velocity = v3zero

	local bg = Instance.new("BodyGyro")
	bg.Name = gyroHandlerName
	bg.Parent = root
	bg.MaxTorque = v3inf
	bg.P = 1000
	bg.D = 50

	mfly1 = speaker.CharacterAdded:Connect(function()
		local bv = Instance.new("BodyVelocity")
		bv.Name = velocityHandlerName
		bv.Parent = root
		bv.MaxForce = v3zero
		bv.Velocity = v3zero

		local bg = Instance.new("BodyGyro")
		bg.Name = gyroHandlerName
		bg.Parent = root
		bg.MaxTorque = v3inf
		bg.P = 1000
		bg.D = 50
	end)

	mfly2 = RunService.RenderStepped:Connect(function()
		root = getRoot(speaker.Character)
		camera = workspace.CurrentCamera
		if speaker.Character:FindFirstChildWhichIsA("Humanoid") and root and root:FindFirstChild(velocityHandlerName) and root:FindFirstChild(gyroHandlerName) then
			local humanoid = speaker.Character:FindFirstChildWhichIsA("Humanoid")
			local VelocityHandler = root:FindFirstChild(velocityHandlerName)
			local GyroHandler = root:FindFirstChild(gyroHandlerName)

			VelocityHandler.MaxForce = v3inf
			GyroHandler.MaxTorque = v3inf
			if not vfly then humanoid.PlatformStand = true end
			GyroHandler.CFrame = camera.CoordinateFrame
			VelocityHandler.Velocity = v3none

			local direction = controlModule:GetMoveVector()
			if direction.X > 0 then
				VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
			end
			if direction.X < 0 then
				VelocityHandler.Velocity = VelocityHandler.Velocity + camera.CFrame.RightVector * (direction.X * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
			end
			if direction.Z > 0 then
				VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
			end
			if direction.Z < 0 then
				VelocityHandler.Velocity = VelocityHandler.Velocity - camera.CFrame.LookVector * (direction.Z * ((vfly and vehicleflyspeed or iyflyspeed) * 50))
			end
		end
	end)
end


local LP = Window:MakeTab({
Name = "Local Player",
Icon = "rbxassetid://6023426915",
PremiumOnly = false
})

local Section = LP:AddSection({
Name = "Player Status"
})

LP:AddTextbox({
Name = "Walk Speed",
Default = "",
TextDisappear = true,
Callback = function(txt)
  game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = txt
end	  
})


LP:AddButton({
Name = "Reset WalkSpeed",
Callback = function()
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
  end    
})
LP:AddTextbox({
Name = "ï¸JumpPower",
Default = "",
TextDisappear = true,
Callback = function(txt)
  game.Players.LocalPlayer.Character.Humanoid.JumpPower = txt
end	  
})
LP:AddButton({
Name = "Reset JumpPower",
Callback = function()
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50
  end    
})
LP:AddTextbox({
Name = "Gravity",
Default = "",
TextDisappear = true,
Callback = function(txt)
  workspace.Gravity = txt
end	   
})
LP:AddButton({
Name = "Reset Gravity",
Callback = function()
        workspace.Gravity = 192.6
  end    
})
LP:AddTextbox({
Name = "Hipheight",
Default = "",
TextDisappear = true,
Callback = function(txt)
  game.Players.LocalPlayer.Character.Humanoid.HipHeight = txt
end	  
})

LP:AddButton({
    Name = "Reset Hipheight",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")

        if humanoid then
            if humanoid.RigType == Enum.HumanoidRigType.R6 then
                humanoid.HipHeight = 0
            elseif humanoid.RigType == Enum.HumanoidRigType.R15 then
                humanoid.HipHeight = 2.3
            end
        end
    end
})

LP:AddTextbox({
Name = "Fov",
Default = "",
TextDisappear = true,
Callback = function(txt)
  game.Workspace.CurrentCamera.FieldOfView = txt
end	  
})

LP:AddButton({
Name = "Reset Fov",
Callback = function()
        game.Workspace.CurrentCamera.FieldOfView = 70
  end    
})

LP:AddTextbox({
  Name = "Spin",
  Default = "",
  TextDisappear = true,
  Callback = function(txt)
      spinSpeed = txt
      for i,v in pairs(getRoot(game.Players.LocalPlayer.Character):GetChildren()) do
          if v.Name == "Spinning" then
              v:Destroy()
          end
      end
      local Spin = Instance.new("BodyAngularVelocity")
      Spin.Name = "Spinning"
      Spin.Parent = getRoot(speaker.Character)
      Spin.MaxTorque = Vector3.new(0, math.huge, 0)
      Spin.AngularVelocity = Vector3.new(0,spinSpeed,0)
  end	  
})

LP:AddButton({
  Name = "Unspin",
  Callback = function()
      function getRoot(char)
          local rootPart = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') or char:FindFirstChild('UpperTorso')
          return rootPart
      end

      for i,v in pairs(getRoot(game.Players.LocalPlayer.Character):GetChildren()) do
          if v.Name == "Spinning" then
              v:Destroy()
          end
      end 		
  end    
})

LP:AddButton({
Name = "Reset All",
Callback = function()
      game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
    game.Players.LocalPlayer.Character.Humanoid.JumpPower = 50
    workspace.Gravity = 192.6
    game.Workspace.CurrentCamera.FieldOfView = 70
local player = game.Players.LocalPlayer
        local character = player.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")

        if humanoid then
            if humanoid.RigType == Enum.HumanoidRigType.R6 then
                humanoid.HipHeight = 0
            elseif humanoid.RigType == Enum.HumanoidRigType.R15 then
                humanoid.HipHeight = 2.3
            end
        end
  end   
})

local Section = LP:AddSection({
Name = "Player Scripts"
})

LP:AddButton({
Name = "Rejoin",
Callback = function()
    game:GetService("TeleportService"):Teleport(game.PlaceId)		
  end    
})

LP:AddButton({
  Name = "Reset",
Callback = function()
    game.Players.LocalPlayer.Character.Head:Destroy()
  end    
})

local sethidden = sethiddenproperty or set_hidden_property or set_hidden_prop

LP:AddButton({
	Name = "unAnchored Parts to You",
	Callback = function()
      	if sethidden then
			local Forces = {}
			for _,part in pairs(game.Workspace:GetDescendants()) do
				if game.Players.LocalPlayer.Character:FindFirstChild("Head") and part:IsA("BasePart" or "UnionOperation" or "Model") and part.Anchored == false and not part:IsDescendantOf(plr.Character) and part.Name == "Torso" == false and part.Name == "Head" == false and part.Name == "Right Arm" == false and part.Name == "Left Arm" == false and part.Name == "Right Leg" == false and part.Name == "Left Leg" == false and part.Name == "HumanoidRootPart" == false then
					for i,c in pairs(part:GetChildren()) do
						if c:IsA("BodyPosition") or c:IsA("BodyGyro") then
							c:Destroy()
						end
					end
					local ForceInstance = Instance.new("BodyPosition")
					ForceInstance.Parent = part
					ForceInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
					table.insert(Forces, ForceInstance)
					if not table.find(frozenParts,part) then
						table.insert(frozenParts,part)
					end
				end
			end
			if not simRadius then
				SimRad()
			end
			for i,c in pairs(Forces) do
				c.Position = plr.Character.Head.Position
			end
		end
	end    
})

LP:AddButton({
Name = "Full Bright",
Callback = function()
                 if not _G.FullBrightExecuted then

   _G.FullBrightEnabled = false

   _G.NormalLightingSettings = {
     Brightness = game:GetService("Lighting").Brightness,
     ClockTime = game:GetService("Lighting").ClockTime,
     FogEnd = game:GetService("Lighting").FogEnd,
     GlobalShadows = game:GetService("Lighting").GlobalShadows,
     Ambient = game:GetService("Lighting").Ambient
   }

   game:GetService("Lighting"):GetPropertyChangedSignal("Brightness"):Connect(function()
     if game:GetService("Lighting").Brightness ~= 1 and game:GetService("Lighting").Brightness ~= _G.NormalLightingSettings.Brightness then
       _G.NormalLightingSettings.Brightness = game:GetService("Lighting").Brightness
       if not _G.FullBrightEnabled then
         repeat
           wait()
         until _G.FullBrightEnabled
       end
       game:GetService("Lighting").Brightness = 1
     end
   end)

   game:GetService("Lighting"):GetPropertyChangedSignal("ClockTime"):Connect(function()
     if game:GetService("Lighting").ClockTime ~= 12 and game:GetService("Lighting").ClockTime ~= _G.NormalLightingSettings.ClockTime then
       _G.NormalLightingSettings.ClockTime = game:GetService("Lighting").ClockTime
       if not _G.FullBrightEnabled then
         repeat
           wait()
         until _G.FullBrightEnabled
       end
       game:GetService("Lighting").ClockTime = 12
     end
   end)

   game:GetService("Lighting"):GetPropertyChangedSignal("FogEnd"):Connect(function()
     if game:GetService("Lighting").FogEnd ~= 786543 and game:GetService("Lighting").FogEnd ~= _G.NormalLightingSettings.FogEnd then
       _G.NormalLightingSettings.FogEnd = game:GetService("Lighting").FogEnd
       if not _G.FullBrightEnabled then
         repeat
           wait()
         until _G.FullBrightEnabled
       end
       game:GetService("Lighting").FogEnd = 786543
     end
   end)

   game:GetService("Lighting"):GetPropertyChangedSignal("GlobalShadows"):Connect(function()
     if game:GetService("Lighting").GlobalShadows ~= false and game:GetService("Lighting").GlobalShadows ~= _G.NormalLightingSettings.GlobalShadows then
       _G.NormalLightingSettings.GlobalShadows = game:GetService("Lighting").GlobalShadows
       if not _G.FullBrightEnabled then
         repeat
           wait()
         until _G.FullBrightEnabled
       end
       game:GetService("Lighting").GlobalShadows = false
     end
   end)

   game:GetService("Lighting"):GetPropertyChangedSignal("Ambient"):Connect(function()
     if game:GetService("Lighting").Ambient ~= Color3.fromRGB(178, 178, 178) and game:GetService("Lighting").Ambient ~= _G.NormalLightingSettings.Ambient then
       _G.NormalLightingSettings.Ambient = game:GetService("Lighting").Ambient
       if not _G.FullBrightEnabled then
         repeat
           wait()
         until _G.FullBrightEnabled
       end
       game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
     end
   end)

   game:GetService("Lighting").Brightness = 1
   game:GetService("Lighting").ClockTime = 12
   game:GetService("Lighting").FogEnd = 786543
   game:GetService("Lighting").GlobalShadows = false
   game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)

   local LatestValue = true
   spawn(function()
     repeat
       wait()
     until _G.FullBrightEnabled
     while wait() do
       if _G.FullBrightEnabled ~= LatestValue then
         if not _G.FullBrightEnabled then
           game:GetService("Lighting").Brightness = _G.NormalLightingSettings.Brightness
           game:GetService("Lighting").ClockTime = _G.NormalLightingSettings.ClockTime
           game:GetService("Lighting").FogEnd = _G.NormalLightingSettings.FogEnd
           game:GetService("Lighting").GlobalShadows = _G.NormalLightingSettings.GlobalShadows
           game:GetService("Lighting").Ambient = _G.NormalLightingSettings.Ambient
         else
           game:GetService("Lighting").Brightness = 1
           game:GetService("Lighting").ClockTime = 12
           game:GetService("Lighting").FogEnd = 786543
           game:GetService("Lighting").GlobalShadows = false
           game:GetService("Lighting").Ambient = Color3.fromRGB(178, 178, 178)
         end
         LatestValue = not LatestValue
       end
     end
   end)
 end

 _G.FullBrightExecuted = true
 _G.FullBrightEnabled = not _G.FullBrightEnabled		
  end    
})

LP:AddButton({
Name = "Max Zoom",
Callback = function()
      game.Players.LocalPlayer.CameraMaxZoomDistance = math.huge
  end    
})

LP:AddButton({
	Name = "FirstP",
	Callback = function()
      	game.Players.LocalPlayer.CameraMode = "LockFirstPerson"
  	end   
})


LP:AddButton({
Name = "ThirdP",
Callback = function()
      game.Players.LocalPlayer.CameraMaxZoomDistance = 50
game.Players.LocalPlayer.CameraMode = "Classic"	
  end    
})

LP:AddToggle({
Name = "Show Fps ",
Default = false,
Callback = function(state)
if state then
      local ToolNameGrabber = Instance.new("ScreenGui")
      ToolNameGrabber.Name = "ToolNameGrabber"
      ToolNameGrabber.Parent = game.CoreGui
      ToolNameGrabber.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
      ToolNameGrabber.Enabled = true

      local ToolNameTxt = Instance.new("TextLabel")
      ToolNameTxt.Name = "ToolNameTxt"
      ToolNameTxt.Parent = ToolNameGrabber
      ToolNameTxt.BackgroundColor3 = Color3.new(1, 1, 1)
      ToolNameTxt.BackgroundTransparency = 1
      ToolNameTxt.BorderColor3 = Color3.new(0, 0, 0)
      ToolNameTxt.Position = UDim2.new(0.894944727, 0, 0.952606618, 0)
      ToolNameTxt.Size = UDim2.new(0, 133, 0, 30)
      ToolNameTxt.Font = Enum.Font.GothamSemibold
      ToolNameTxt.Text = "FPS: 0"
      ToolNameTxt.TextColor3 = Color3.new(0, 1, 0)
      ToolNameTxt.TextScaled = true
      ToolNameTxt.TextSize = 14
      ToolNameTxt.TextWrapped = true
      ToolNameTxt.Visible = true

      local FpsLabel = ToolNameTxt
      local Heartbeat = game:GetService("RunService").Heartbeat
      local LastIteration
      local FrameUpdateTable = {}
      local Start = tick()

      local function HeartbeatUpdate()
          LastIteration = tick()
          for Index = #FrameUpdateTable, 1, -1 do
              FrameUpdateTable[Index + 1] = (FrameUpdateTable[Index] >= LastIteration - 1) and FrameUpdateTable[Index] or nil
          end
          FrameUpdateTable[1] = LastIteration
          local CurrentFPS = (tick() - Start >= 1 and #FrameUpdateTable) or (#FrameUpdateTable / (tick() - Start))
          FpsLabel.Text = "FPS: " .. math.floor(CurrentFPS)
      end

      Heartbeat:Connect(HeartbeatUpdate)
  else
      for _, fps in pairs(game.CoreGui:GetDescendants()) do
          if fps.Name == "ToolNameGrabber" then
              fps:Destroy()
          end
      end
  end
end    
})

LP:AddToggle({
Name = "Show Ping",
Default = false,
Callback = function(state)
  if state then
      local PingGrabber = Instance.new("ScreenGui")
      PingGrabber.Name = "PingGrabber"
      PingGrabber.Parent = game.CoreGui
      PingGrabber.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
      PingGrabber.Enabled = true

      local ToolNameTxt = Instance.new("TextLabel")
      ToolNameTxt.Name = "ToolNameTxt"
      ToolNameTxt.Parent = PingGrabber
      ToolNameTxt.BackgroundColor3 = Color3.new(1, 1, 1)
      ToolNameTxt.BackgroundTransparency = 1
      ToolNameTxt.BorderColor3 = Color3.new(0, 0, 0)
      ToolNameTxt.Position = UDim2.new(0.8, 0, 0.952606618, 0)
      ToolNameTxt.Size = UDim2.new(0, 133, 0, 30)
      ToolNameTxt.Font = Enum.Font.GothamSemibold
      ToolNameTxt.Text = "Ping: 0 ms"
      ToolNameTxt.TextColor3 = Color3.new(0, 1, 0)
      ToolNameTxt.TextScaled = true
      ToolNameTxt.TextSize = 14
      ToolNameTxt.TextWrapped = true
      ToolNameTxt.Visible = true

      local PingLabel = ToolNameTxt
      local Heartbeat = game:GetService("RunService").Heartbeat
      local LastIteration
      local FrameUpdateTable = {}

      local function HeartbeatUpdate()
          LastIteration = tick()
          for Index = #FrameUpdateTable, 1, -1 do
              FrameUpdateTable[Index + 1] = (FrameUpdateTable[Index] >= LastIteration - 1) and FrameUpdateTable[Index] or nil
          end
          FrameUpdateTable[1] = LastIteration
          local Current_Ping = tonumber(string.split(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString(), " ")[1])
          PingLabel.Text = "Ping: " .. Current_Ping .. " ms"
      end

      Heartbeat:Connect(HeartbeatUpdate)
  else
      for _, ping in pairs(game.CoreGui:GetDescendants()) do
          if ping.Name == "PingGrabber" then
              ping:Destroy()
          end
      end
  end

end    
})

local flying = true
local deb = true
local ctrl = {f = 0, b = 0, l = 0, r = 0}
local lastctrl = {f = 0, b = 0, l = 0, r = 0}
local KeyDownFunction = nil
local KeyUpFunction = nil

LP:AddToggle({
	Name = "Fly",
	Default = false,
	Callback = function(state)
if state == true then
if not IsOnMobile then
		NOFLY()
		wait()
		sFLY()
	else
		mobilefly(speaker)
	end
	else
		if not IsOnMobile then NOFLY() else unmobilefly(speaker) end
		end
  end    
})

LP:AddTextbox({
Name = "CFrame Fly Speed",
Default = "",
TextDisappear = true,
Callback = function(cFlyspeed)
  iyflyspeed = cFlyspeed
end	
})


LP:AddToggle({
Name = "CFrame Fly",
Default = false,
Callback = function(cFly)
  if cFly == true then
             plr.Character:FindFirstChildOfClass('Humanoid').PlatformStand = true
local Head = plr.Character:WaitForChild("Head")
Head.Anchored = true
CFloop = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
  local moveDirection = plr.Character:FindFirstChildOfClass('Humanoid').MoveDirection * (CFspeed * deltaTime)
  local headCFrame = Head.CFrame
  local cameraCFrame = game.Workspace.CurrentCamera.CFrame
  local cameraOffset = headCFrame:ToObjectSpace(cameraCFrame).Position
  cameraCFrame = cameraCFrame * CFrame.new(-cameraOffset.X, -cameraOffset.Y, -cameraOffset.Z + 1)
  local cameraPosition = cameraCFrame.Position
  local headPosition = headCFrame.Position

  local objectSpaceVelocity = CFrame.new(cameraPosition, Vector3.new(headPosition.X, cameraPosition.Y, headPosition.Z)):VectorToObjectSpace(moveDirection)
  Head.CFrame = CFrame.new(headPosition) * (cameraCFrame - cameraPosition) * CFrame.new(objectSpaceVelocity)
end)
        else
             cFly = false
             if CFloop then
  CFloop:Disconnect()
  plr.Character:FindFirstChildOfClass('Humanoid').PlatformStand = false
  local Head = plr.Character:WaitForChild("Head")
  Head.Anchored = false
end
end
end    
})

LP:AddTextbox({
Name = "CFrame Fly Speed",
Default = "",
TextDisappear = true,
Callback = function(cFlyspeed)
  CFspeed = cFlyspeed
end	
})

LP:AddToggle({
Name = "Fly Fling",
Default = false,
Callback = function(Fly)
  if Fly == true then
             	if not IsOnMobile then NOFLY() else unmobilefly(speaker) end
wait()
  for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
  if v:IsA("Part") then

v.CustomPhysicalProperties = PhysicalProperties.new(9e99, 9e99, 9e99, 9e99, 9e99)
end
end
  Noclip()
if not IsOnMobile then
		wait()
		sFLY()
	else
		mobilefly(speaker)
	end
  local BodyAV = Instance.new("BodyAngularVelocity", game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart"))
BodyAV.AngularVelocity = Vector3.new(0, 2000, 0)
BodyAV.MaxTorque = Vector3.new(0, math.huge, 0)
BodyAV.Name = "FlyFling"
BodyAV.P = 1250
        else
             Fly = false
            	if not IsOnMobile then NOFLY() else unmobilefly(speaker) end
             for _, child in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
  if child.ClassName == "Part" then
    child.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 0.5, 0, 0)
  end
end
             for i,v in pairs(plr.Character:GetDescendants()) do
                 if v:IsA("BodyAngularVelocity") and v.Name == "FlyFling" then
                    v:Destroy()
                 end
             end
             vNoclip = false
    if Noclipping then
  Noclipping:Disconnect()
end
Clip = true
end
end    
})

LP:AddTextbox({
Name = "Fly Fling Speed",
Default = "",
TextDisappear = true,
Callback = function(vFlyspeedsz)
  vehicleflyspeed = vFlyspeedsz
  end	
})

LP:AddToggle({
  Name = "Infinite Jump ",
  Default = false,
  Callback = function(jumpsFly)
    if jumpsFly == true then
               if flyjump then 
            flyjump:Disconnect() 
         end
  flyjump = UserInputService.JumpRequest:Connect(function(Jump)
    game:GetService"Players".LocalPlayer.Character:FindFirstChildOfClass'Humanoid':ChangeState("Jumping")
  end)
          else
               jumpsFly = false
               if flyjump then 
          flyjump:Disconnect() 
         end
  end
  end    
})

LP:AddToggle({
	Name = "Freeze",
	Default = false,
	Callback = function(plrfree)
        if plrfree == true then
            for i,v in pairs(plr.Character:GetDescendants()) do
                if v:IsA("BasePart") then
                v.Anchored = true
            end
            end
		else
		    plrfree = false
			for i,v in pairs(plr.Character:GetDescendants()) do
                if v:IsA("BasePart") then
                v.Anchored = false
            end
            end
		end		
  end    
})

LP:AddToggle({
	Name = "Invisible",
	Default = false,
	Callback = function(invisibleofc)
		if invisibleofc == true then
              if invisRunning then return end
	invisRunning = true
	-- Full credit to AmokahFox @V3rmillion
	local Player = plr
	repeat wait(.1) until Player.Character
	local Character = Player.Character
	Character.Archivable = true
	InvisibleCharacter = Character:Clone()
	InvisibleCharacter.Parent = game:GetService'Lighting'
	local Void = game.Workspace.FallenPartsDestroyHeight
	InvisibleCharacter.Name = ""
	     invisFix = game:GetService("RunService").Stepped:Connect(function()
		pcall(function()
			local IsInteger
			if tostring(Void):find'-' then
				IsInteger = true
			else
				IsInteger = false
			end
			local Pos = Player.Character.HumanoidRootPart.Position
			local Pos_String = tostring(Pos)
			local Pos_Seperate = Pos_String:split(', ')
			local X = tonumber(Pos_Seperate[1])
			local Y = tonumber(Pos_Seperate[2])
			local Z = tonumber(Pos_Seperate[3])
			if IsInteger == true then
				if Y <= Void then
					invisRespawn()
				end
			elseif IsInteger == false then
				if Y >= Void then
					invisRespawn()
				end
			end
		end)
	end)
	      for i,v in pairs(InvisibleCharacter:GetDescendants())do
		if v:IsA("BasePart") then
			if v.Name == "HumanoidRootPart" then
				v.Transparency = 1
			else
				v.Transparency = .5
			end
		end
	end
	invisDied = InvisibleCharacter:FindFirstChildOfClass'Humanoid'.Died:Connect(function()
		invisRespawn()
		invisDied:Disconnect()
	end)
	if IsInvis == true then return end
	IsInvis = true
	CF = game.Workspace.CurrentCamera.CFrame
	local CF_1 = Player.Character.HumanoidRootPart.CFrame
	Character:MoveTo(Vector3.new(0,math.pi*1000000,0))
	game.Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
	wait(.2)
	game.Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
	InvisibleCharacter = InvisibleCharacter
	Character.Parent = game:GetService'Lighting'
	InvisibleCharacter.Parent = game.Workspace
	InvisibleCharacter.HumanoidRootPart.CFrame = CF_1
	Player.Character = InvisibleCharacter
	fixcam()
	Player.Character.Animate.Disabled = true
	Player.Character.Animate.Disabled = false
          else
               invisibleofc = false
			   TurnVisible()
	end
  end    
})

LP:AddToggle({
	Name = "Air Walk",
	Default = false,
	Callback = function(state)
if state == true then
local Chat = game:GetService('Players').LocalPlayer.Chatted
				 local function AirWalk()
 
					 local AirWPart = Instance.new("Part", workspace)
					 local crtl = true
					 local Mouse = game.Players.LocalPlayer:GetMouse()
					 AirWPart.Size = Vector3.new(7, 2, 3)
					 AirWPart.CFrame = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, -4, 0)
					 AirWPart.Transparency = 1
					 AirWPart.Anchored = true
					 AirWPart.Name = "Airwalk"
					 for i = 1, math.huge do
						 AirWPart.CFrame = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, -4, 0)
						 wait (.1)
					 end
				 end
				 AirWalk()
				else
					 for i, v in pairs(workspace:GetChildren()) do
		 if tostring(v) == "Airwalk" then
			 v:Destroy()
	 end
 end
 end
  end    
})


LP:AddToggle({
  Name = "Noclip",
  Default = false,
  Callback = function(Noclip)
        if Noclip == true then
            Clip = false
  wait(0.1)
  local function NoclipLoop()
    if Clip == false and plr.Character ~= nil then
      for _, child in pairs(plr.Character:GetDescendants()) do
        if child:IsA("BasePart") and child.CanCollide == true then
          child.CanCollide = false
        end
      end
    end
  end
  Noclipping = game:GetService('RunService').Stepped:Connect(NoclipLoop)
    else
        Noclip = false
      if Noclipping then
    Noclipping:Disconnect()
  end
  Clip = true
    end		
  end    
})

LP:AddToggle({
  Name = "Fake Lag",
  Default = false,
  Callback = function(fakelaglol)
    if fakelaglol == true then
               Lagging = true
  repeat wait()
    plr.Character.HumanoidRootPart.Anchored = false
    wait(1.5)
    plr.Character.HumanoidRootPart.Anchored = true
    wait(3)
  until Lagging == false
          else
               fakelaglol = false
               Lagging = false
         wait(.3)
  plr.Character.HumanoidRootPart.Anchored = false
  end
  end    
})

LP:AddToggle({
  Name = "Super Fake Lag",
  Default = false,
  Callback = function(fakelaglol)
    if fakelaglol == true then
               Lagging = true
  repeat wait()
    plr.Character.HumanoidRootPart.Anchored = false
    wait(.1)
    plr.Character.HumanoidRootPart.Anchored = true
    wait(.1)
  until Lagging == false
          else
               fakelaglol = false
               Lagging = false
         wait(.3)
  plr.Character.HumanoidRootPart.Anchored = false
  end
  end    
})

LP:AddToggle({
	Name = "Walk Fling",
	Default = false,
	Callback = function(state)
	if state == true then
if game:GetService("ReplicatedStorage"):FindFirstChild("juisdfj0i32i0eidsuf0iok") then
     hiddenfling = true
   else
     hiddenfling = true
     detection = Instance.new("Decal")
     detection.Name = "juisdfj0i32i0eidsuf0iok"
     detection.Parent = game:GetService("ReplicatedStorage")
     local function fling()
       local hrp, c, vel, movel = nil, nil, nil, 0.1
       while true do
         game:GetService("RunService").Heartbeat:Wait()
         if hiddenfling then
           local lp = game.Players.LocalPlayer
           while hiddenfling and not (c and c.Parent and hrp and hrp.Parent) do
             game:GetService("RunService").Heartbeat:Wait()
             c = lp.Character
             hrp = c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
           end
           if hiddenfling then
             vel = hrp.Velocity
             hrp.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)
             game:GetService("RunService").RenderStepped:Wait()
             if c and c.Parent and hrp and hrp.Parent then
               hrp.Velocity = vel
             end
             game:GetService("RunService").Stepped:Wait()
             if c and c.Parent and hrp and hrp.Parent then
               hrp.Velocity = vel + Vector3.new(0, movel, 0)
               movel = movel * -1
             end
           end
         end
       end
     end

     fling()
      end   	
      else
      hiddenfling = false
      end
  end    
})

LP:AddButton({
  Name = "Fling Attachment",
  Callback = function()
        loadcharacter(plr.Character)
    end    
})


LP:AddToggle({
	Name = "Spin Fling",
	Default = false,
	Callback = function(state)
		if state == true then
			flinging = false
			for _, child in pairs(speaker.Character:GetDescendants()) do
				if child:IsA("BasePart") then
					child.CustomPhysicalProperties = PhysicalProperties.new(math.huge, 0.3, 0.5)
				end
			end
			Clip = false
			wait(0.1)

			local function NoclipLoop()
				if Clip == false and speaker.Character then
					for _, child in pairs(speaker.Character:GetDescendants()) do
						if child:IsA("BasePart") and child.CanCollide == true and child.Name ~= floatName then
							child.CanCollide = false
						end
					end
				end
			end

			Noclipping = RunService.Stepped:Connect(NoclipLoop)
			wait(0.1)

			local bambam = Instance.new("BodyAngularVelocity")
			bambam.Name = randomString()
			bambam.Parent = getRoot(speaker.Character)
			bambam.AngularVelocity = Vector3.new(0, 99999, 0)
			bambam.MaxTorque = Vector3.new(0, math.huge, 0)
			bambam.P = math.huge

			for _, v in pairs(speaker.Character:GetChildren()) do
				if v:IsA("BasePart") then
					v.CanCollide = false
					v.Massless = true
					v.Velocity = Vector3.new(0, 0, 0)
				end
			end
			flinging = true

			local function flingDiedF()
				if Noclipping then
					Noclipping:Disconnect()
				end
				flinging = false
				Clip = true
			end
			flingDied = speaker.Character:FindFirstChildOfClass('Humanoid').Died:Connect(flingDiedF)

			repeat
				bambam.AngularVelocity = Vector3.new(0, 99999, 0)
				wait(0.2)
				bambam.AngularVelocity = Vector3.new(0, 0, 0)
				wait(0.1)
			until flinging == false

		else
			if Noclipping then
				Noclipping:Disconnect()
			end
			Clip = true
			if flingDied then
				flingDied:Disconnect()
			end
			flinging = false
			wait(0.1)
			local speakerChar = speaker.Character
			if not speakerChar or not getRoot(speakerChar) then return end
			for _, v in pairs(getRoot(speakerChar):GetChildren()) do
				if v:IsA('BodyAngularVelocity') then
					v:Destroy()
				end
			end
			for _, child in pairs(speakerChar:GetDescendants()) do
				if child:IsA("Part") or child:IsA("MeshPart") then
					child.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 0.5)
				end
			end
		end
	end
})


local Player = Window:MakeTab({
Name = "Troll",
Icon = "rbxassetid://6034281935",
PremiumOnly = false
})



local Target
local KillConnection -- Store the connection for toggling on/off
local NotificationSent = false -- Track if the notification has been sent

local players = {}
local Target = nil

-- Function to update the players list
local function UpdatePlayers()
    players = {}
    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
        table.insert(players, v.DisplayName .. " (" .. v.Name .. ")")
    end
end

-- Initial population of the players list
UpdatePlayers()

-- Dropdown for selecting a player
local PlayerDropdown = Player:AddDropdown({
    Name = "Select Player",
    Default = "Select Player",
    Options = players, -- Initial options
    Callback = function(selected)
        Target = selected
    end    
})

-- Function to refresh the dropdown options
local function RefreshDropdown()
    UpdatePlayers()
    PlayerDropdown:Refresh(players, true) -- Refresh the dropdown with updated players list
end

-- Update players list when a player is added
game:GetService("Players").PlayerAdded:Connect(function()
    RefreshDropdown()
end)

-- Update players list when a player is removed
game:GetService("Players").PlayerRemoving:Connect(function(player)
    -- Notify if the selected player leaves
    if Target and player and string.find(Target, player.Name) then
        OrionLib:MakeNotification({
            Name = "Warning",
            Content = player.DisplayName .. " (" .. player.Name .. ") has left the game!",
            Image = "rbxassetid://6031075938",  
            Time = 5
        })
    end
    RefreshDropdown()
end)

-- Click At Target functionality
Player:AddButton({
	Name = "Click At Target",
	Callback = function()
        -- Create the Tool
        local GetTargetTool = Instance.new("Tool")
        GetTargetTool.Name = "ClickTarget"
        GetTargetTool.RequiresHandle = false
        GetTargetTool.ToolTip = "Select A Target"

        -- Function to activate the tool
        local function ActivateTool()
            local player = game.Players.LocalPlayer
            local mouse = player:GetMouse()
            local hit = mouse.Target

            if hit then
                local character = hit.Parent
                local person = game.Players:GetPlayerFromCharacter(character)

                if person then
                    -- Update the Target and dropdown selection
                    Target = person.DisplayName .. " (" .. person.Name .. ")"
                    
                    -- Update the dropdown to reflect the new selection
                    PlayerDropdown:Set(Target)
                    
                    -- Notify the player
                    OrionLib:MakeNotification({
                        Name = "Target Selected",
                        Content = "Selected Target: " .. person.DisplayName,
                        Image = "rbxassetid://6031075938",
                        Time = 5
                    })
                else
                    
                end
            end
        end

        -- Tool activation event
        GetTargetTool.Activated:Connect(ActivateTool)

        -- Adding the Tool to LocalPlayer's Backpack
        local plr = game.Players.LocalPlayer
        GetTargetTool.Parent = plr.Backpack
    end    
})

-- Information button functionality
Player:AddButton({
    Name = "Information",
    Callback = function()
        local playerName = string.match(Target, "%(([^)]+)%)")
        local playerTarget = game.Players:FindFirstChild(playerName)

        if playerTarget and playerTarget.Character and playerTarget.Character:FindFirstChildOfClass('Humanoid') then
            OrionLib:MakeNotification({
                Name = "Information about Player:",
                Content = 'Name: ' .. playerTarget.Name ..
                          ' | Character Name: ' .. playerTarget.Character.Name ..
                          ' | DisplayName: ' .. playerTarget.DisplayName ..
                          ' | Account Age: ' .. playerTarget.AccountAge ..
                          ' | User ID: ' .. playerTarget.UserId ..
                          ' | Health: ' .. math.round(playerTarget.Character:FindFirstChildOfClass('Humanoid').Health, 1) ..
                          ' | WalkSpeed: ' .. playerTarget.Character:FindFirstChildOfClass("Humanoid").WalkSpeed ..
                          ' | JumpPower: ' .. playerTarget.Character:FindFirstChildOfClass("Humanoid").JumpPower,
                Image = "",
                Time = 10
            })
        end
    end
})


local Velocity_Asset = Instance.new("BodyAngularVelocity")
Velocity_Asset.AngularVelocity = Vector3.new(0, 0, 0)
Velocity_Asset.MaxTorque = Vector3.new(50000, 50000, 50000)
Velocity_Asset.P = 1250
Velocity_Asset.Name = "BreakVelocity"



Player:AddButton({
  Name = "Teleport",
  Callback = function()
      local playerName = string.match(Target, "%(([^)]+)%)")


      local targetPlayer = game.Players:FindFirstChild(playerName)
          game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame

      end
})


Player:AddButton({
  Name = "Tween Teleport",
  Callback = function()
      local playerName = string.match(Target, "%(([^)]+)%)")
      local targetPlayer = game.Players:FindFirstChild(playerName)

          local char = game.Players.LocalPlayer
          local targetHRP = targetPlayer.Character.HumanoidRootPart

          local tween = TweenService:Create(char.Character.HumanoidRootPart, TweenInfo.new(2, Enum.EasingStyle.Linear), {CFrame = targetHRP.CFrame + Vector3.new(3, 1, 0)})
          tween:Play()
  end
})




Player:AddToggle({
    Name = "FE Kill",
    Default = false,
    Callback = function(state)
        if state then
            local player = game:GetService("Players").LocalPlayer
            NotificationSent = false -- Reset the flag when the toggle is activated

            -- Ensure only one task is running
            if KillConnection then
                KillConnection:Disconnect()
                KillConnection = nil
            end

            KillConnection = game:GetService("RunService").RenderStepped:Connect(function()
                if not Target then return end

                -- Extract player name from the dropdown selection
                local playerName = string.match(Target, "%(([^)]+)%)")
                local PlayerTarget = game.Players:FindFirstChild(playerName)
                local Char = player.Character
                local Tool = Char and Char:FindFirstChildWhichIsA("Tool")
                local Handle = Tool and Tool:FindFirstChild("Handle")

                -- Ensure that the tool has a handle and is capable of dealing damage
                if Tool and Handle and PlayerTarget and PlayerTarget.Character then
                    local Human = PlayerTarget.Character:FindFirstChildWhichIsA("Humanoid")
                    if not Human or Human.Health <= 0 then
                        if not NotificationSent then
                            OrionLib:MakeNotification({
                                Name = "Warning",
                                Content = "Target player is already dead or left.",
                                Image = "rbxassetid://6031075938", -- Checkmark icon
                                Time = 5
                            })
                            NotificationSent = true
                        end
                        return
                    end

                    -- Spawn a loop to fire touch interest events with the handle
                    task.spawn(function()
                        while Tool and Char and PlayerTarget.Character and Tool.Parent == Char do
                            for _, v in ipairs(PlayerTarget.Character:GetChildren()) do
                                if v:IsA("BasePart") then
                                Tool:Activate()
                                    firetouchinterest(Handle, v, 0)
                                    firetouchinterest(Handle, v, 1)
                                end
                            end
                            task.wait(0.1) -- Control the loop speed
                        end
                    end)
                else
                    -- Show the notification only once if not already sent
                    if not NotificationSent then
                        OrionLib:MakeNotification({
                            Name = "Warning",
                            Content = "You need a tool that can deal damage.",
                            Image = "rbxassetid://6031075938", -- Checkmark icon
                            Time = 5
                        })
                        NotificationSent = true -- Mark the notification as sent
                    end
                end
            end)
        else
            -- Disconnect the loop when the toggle is switched off
            if KillConnection then
                KillConnection:Disconnect()
                KillConnection = nil
            end
        end
    end    
})

Player:AddToggle({
    Name = "FE Kill All",
    Default = false,
    Callback = function(state)
        if state then
            NotificationSent = false -- Reset the flag when the toggle is activated

            -- Ensure only one task is running
            if KillAllConnection then
                KillAllConnection:Disconnect()
                KillAllConnection = nil
            end

            KillAllConnection = game:GetService("RunService").RenderStepped:Connect(function()
                local Char = plr.Character
                local Tool = Char and Char:FindFirstChildWhichIsA("Tool")
                local Handle = Tool and Tool:FindFirstChild("Handle")

                -- Ensure that the tool has a handle and is capable of dealing damage
                if Tool and Handle then
                    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
                        -- Skip the local player
                        if otherPlayer ~= plr and otherPlayer.Character then
                            local Human = otherPlayer.Character:FindFirstChildWhichIsA("Humanoid")
                            if Human and Human.Health > 0 then
                                -- Fire touch interest events with the handle for each player part
                                task.spawn(function()
                                    for _, part in ipairs(otherPlayer.Character:GetChildren()) do
                                        if part:IsA("BasePart") then
                                        Tool:Activate()
                                            firetouchinterest(Handle, part, 0)
                                            firetouchinterest(Handle, part, 1)
                                        end
                                    end
                                end)
                            end
                        end
                    end
                else
                    -- Show the notification only once if not already sent
                    if not NotificationSent then
                        OrionLib:MakeNotification({
                            Name = "Warning",
                            Content = "You need a tool that can deal damage.",
                            Image = "rbxassetid://6031075938", -- Checkmark icon
                            Time = 5
                        })
                        NotificationSent = true -- Mark the notification as sent
                    end
                end
            end)
        else
            -- Disconnect the loop when the toggle is switched off
            if KillAllConnection then
                KillAllConnection:Disconnect()
                KillAllConnection = nil
            end
        end
    end    
})

Player:AddButton({
	Name = "Tp UnAnchored Parts to Player",
	Callback = function()
      	if sethidden then
			local Forces = {}
			for _,part in pairs(game.Workspace:GetDescendants()) do
				if PlayerTarget.Character:FindFirstChild("Head") and part:IsA("BasePart" or "UnionOperation" or "Model") and part.Anchored == false and not part:IsDescendantOf(plr.Character) and part.Name == "Torso" == false and part.Name == "Head" == false and part.Name == "Right Arm" == false and part.Name == "Left Arm" == false and part.Name == "Right Leg" == false and part.Name == "Left Leg" == false and part.Name == "HumanoidRootPart" == false then
					for i,c in pairs(part:GetChildren()) do
						if c:IsA("BodyPosition") or c:IsA("BodyGyro") then
							c:Destroy()
						end
					end
					local ForceInstance = Instance.new("BodyPosition")
					ForceInstance.Parent = part
					ForceInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
					table.insert(Forces, ForceInstance)
					if not table.find(frozenParts,part) then
						table.insert(frozenParts,part)
					end
				end
			end
			if not simRadius then
				SimRad()
			end
			for i,c in pairs(Forces) do
				c.Position = PlayerTarget.Character.Head.Position
			end
		end
	end    
})


Player:AddButton({
	Name = "Fling",
	Callback = function()
	local playerName = string.match(Target, "%(([^)]+)%)")
 local Target = game.Players:FindFirstChild(playerName)
      	SkidFling(Target)
  	end    
})

Player:AddToggle({
     Name = "Loop Fling",
     Default = false,
     Callback = function(state)
 if state == true then
                local playerName = string.match(Target, "%(([^)]+)%)")
 local Targets = game.Players:FindFirstChild(playerName)

      Loopvoid = true
      repeat wait()
  SkidFling(Targets)
      until Loopvoid == false
        else
            Loopvoid = false
        end
    end
 })
 
Player:AddButton({
	Name = "Fling All",
	Callback = function()
       local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= localPlayer then
        SkidFling(player)
    end
end	
  	end    
})

Player:AddToggle({
	Name = "Loop Fling All",
	Default = false,
	Callback = function(state)
if state == true then

      Loopvoid = true
      repeat wait()
  
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= localPlayer then
        SkidFling(player)
    end
end

      until Loopvoid == false
        else
            Loopvoid = false
        end
  end    
})

Player:AddToggle({
    Name = "Animation Steal Player",
    Default = false,
    Callback = function(animsteals)
        local plr = game.Players.LocalPlayer
        if animsteals then
            local playerName = string.match(Target, "%(([^)]+)%)")
            local PlayerTarget = game.Players:FindFirstChild(playerName)

            -- Check if the player's character is in R15
            if plr.Character.Humanoid.RigType ~= Enum.HumanoidRigType.R15 then
                OrionLib:MakeNotification({
                    Name = "Warning",
                    Content = "You should be R15 to steal animation.",
                    Image = "rbxassetid://6031075938",  -- Checkmark icon
                    Time = 5
                })
                return
            end

            -- Check if the target player's character is in R15
            if PlayerTarget.Character.Humanoid.RigType ~= Enum.HumanoidRigType.R15 then
                OrionLib:MakeNotification({
                    Name = "Warning",
                    Content = "The player you are trying to steal from is in R6. Try choosing another player.",
                    Image = "rbxassetid://6031075938",  -- Checkmark icon
                    Time = 5
                })
                return
            end

            if PlayerTarget.Character:FindFirstChild("Animate") then
                if plr.Character:FindFirstChild("Animate") then
                    local checkifmyanim = plr.Character:FindFirstChild("animstorage")
                    if checkifmyanim then
                        plr.Character:FindFirstChild("Animate"):Destroy()
                        checkifmyanim.Name = "Animate"
                        checkifmyanim.Disabled = false
                    end
                end

                local currentAnimate = plr.Character:FindFirstChild("Animate")
                if currentAnimate then
                    currentAnimate.Name = "animstorage"
                    currentAnimate.Disabled = true
                end

                local newAnim = PlayerTarget.Character.Animate:Clone()
                newAnim.Parent = plr.Character
                newAnim.Name = "Animate"
            end
        else
            -- When toggle is off, restore original animations
            if plr.Character:FindFirstChild("animstorage") then
                if plr.Character:FindFirstChild("Animate") then
                    plr.Character:FindFirstChild("Animate"):Destroy()
                end
                local animStorage = plr.Character:FindFirstChild("animstorage")
                animStorage.Name = "Animate"
                animStorage.Disabled = false
            end
        end
    end
})

-- Declare variables outside the function to maintain state
local viewDied = nil
local viewChanged = nil
local viewing = nil
local plr = game.Players.LocalPlayer

Player:AddToggle({
    Name = "View Player",
    Default = false,
    Callback = function(View)
        if View == true then
            -- Disconnect previous connections if any
            if viewDied then
                viewDied:Disconnect()
                viewDied = nil
            end
            if viewChanged then
                viewChanged:Disconnect()
                viewChanged = nil
            end

            -- Extract the player name from the Target variable
            local playerName = string.match(Target, "%(([^)]+)%)")
            local PlayerTarget = game.Players:FindFirstChild(playerName)

            if PlayerTarget and PlayerTarget.Character then
                -- Set the viewing target
                viewing = PlayerTarget
                game.Workspace.CurrentCamera.CameraSubject = viewing.Character

                -- Function to handle character respawn
                local function viewDiedFunc()
                    repeat wait() until PlayerTarget.Character ~= nil and PlayerTarget.Character:FindFirstChild("HumanoidRootPart")
                    game.Workspace.CurrentCamera.CameraSubject = viewing.Character
                end

                -- Connect character added event
                viewDied = PlayerTarget.CharacterAdded:Connect(viewDiedFunc)

                -- Function to handle camera subject change
                local function viewChangedFunc()
                    game.Workspace.CurrentCamera.CameraSubject = viewing.Character
                end

                -- Connect property changed event
                viewChanged = game.Workspace.CurrentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(viewChangedFunc)
            end
        else
            -- Reset the view
            viewing = nil
            if viewDied then
                viewDied:Disconnect()
                viewDied = nil
            end
            if viewChanged then
                viewChanged:Disconnect()
                viewChanged = nil
            end
            game.Workspace.CurrentCamera.CameraSubject = plr.Character
        end
    end    
})

local RunService = game:GetService("RunService")
local t
local bangLoop
local bangDied
local bang
local bangAnim

Player:AddToggle({
    Name = "Bang",
    Default = false,
    Callback = function(bangState)
        if bangState then
            local speed = t
            if speed == nil then
                speed = 10
            end
local playerName = string.match(Target, "%(([^)]+)%)")

      local Target = game.Players:FindFirstChild(playerName)

            bangAnim = Instance.new("Animation")
            if not r15(game.Players.LocalPlayer) then
                bangAnim.AnimationId = "rbxassetid://148840371"
            else
                bangAnim.AnimationId = "rbxassetid://5918726674"
            end

            bang = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(bangAnim)
            bang:Play(.1, 1, 1)
            bang:AdjustSpeed(speed)

            local bangplr = Target.Name
            bangDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                if bangLoop then bangLoop:Disconnect() end
                bang:Stop()
                bangAnim:Destroy()
                bangDied:Disconnect()
            end)

            local bangOffset = CFrame.new(0, 0, 1.1)
            bangLoop = RunService.Stepped:Connect(function()
                pcall(function()
                    local otherRoot = getTorso(game.Players[bangplr].Character)
                    getRoot(game.Players.LocalPlayer.Character).CFrame = otherRoot.CFrame * bangOffset
                end)
            end)
        else
            if bangLoop then bangLoop:Disconnect() end
            if bang then bang:Stop() end
            if bangAnim then
                bangAnim:Destroy()
                bangAnim = nil -- Ensure the reference is cleared
            end
            if bangDied then bangDied:Disconnect() end
        end
    end
})



Player:AddTextbox({
  Name = "Bang Speed",
  Default = "",
  TextDisappear = true,
  Callback = function(h)
     t = tonumber(h)
  end	  
})

local RunService = game:GetService("RunService")
local bangLoop
local bangDied
local bang
local bangAnim

Player:AddToggle({
    Name = "Headbang",
    Default = false,
    Callback = function(Bang)
        if Bang then
            local speed = d

            if speed == nil then
                speed = 10
            end

local playerName = string.match(Target, "%(([^)]+)%)")

      local players = game.Players:FindFirstChild(playerName)


            bangAnim = Instance.new("Animation")
            if not r15(game.Players.LocalPlayer) then
                bangAnim.AnimationId = "rbxassetid://148840371"
            else
                bangAnim.AnimationId = "rbxassetid://5918726674"
            end

            bang = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(bangAnim)
            bang:Play(.1, 1, 1)
            bang:AdjustSpeed(speed)

            local bangplr = players.Name
            bangDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                if bangLoop then bangLoop:Disconnect() end
                if bang then bang:Stop() end
                if bangAnim then bangAnim:Destroy() end
                if bangDied then bangDied:Disconnect() end
            end)

            local bangOffset = CFrame.new(0, 1, -1.1)
            bangLoop = RunService.Stepped:Connect(function()
                pcall(function()
                    local otherRoot = game.Players[bangplr].Character:FindFirstChild("Head")
                    if otherRoot then
                        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = otherRoot.CFrame * bangOffset
                        local CharPos = game.Players.LocalPlayer.Character.PrimaryPart.Position
                        local tpos = players.Character:FindFirstChild("HumanoidRootPart").Position
                        local TPos = Vector3.new(tpos.X, CharPos.Y, tpos.Z)
                        local NewCFrame = CFrame.new(CharPos, TPos)
                        game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(NewCFrame)
                    end
                end)
            end)
        else
            if bangLoop then bangLoop:Disconnect() end
            if bang then bang:Stop() end
            if bangAnim then
                bangAnim:Destroy()
                bangAnim = nil -- Clear reference
            end
            if bangDied then bangDied:Disconnect() end
        end
    end
})




Player:AddTextbox({
  Name = "Headbang Speed ",
  Default = "",
  TextDisappear = true,
  Callback = function(h)
     d = tonumber(h)
  end	  
})

local headSit
local sitLoop
local sitDied

Player:AddToggle({
    Name = "Head Stand",
    Default = false,
    Callback = function(stand)
        if stand then
            if headSit then headSit:Disconnect() end

local playerName = string.match(Target, "%(([^)]+)%)")

      local players = game.Players:FindFirstChild(playerName)


            local sitPlr = players.Name

            sitDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                if sitLoop then sitLoop:Disconnect() end
                if headSit then headSit:Disconnect() end
            end)

            headSit = RunService.Heartbeat:Connect(function()
                if Players:FindFirstChild(players.Name) and players.Character ~= nil and getRoot(players.Character) and getRoot(game.Players.LocalPlayer.Character) then
                    getRoot(game.Players.LocalPlayer.Character).CFrame = players.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(0), 0) * CFrame.new(0, 4.6, 0.4)
                else
                    if headSit then headSit:Disconnect() end
                end
            end)
        else
            if headSit then headSit:Disconnect() end
            if sitDied then sitDied:Disconnect() end
        end
    end
})


Player:AddToggle({
  Name = "Head Sit",
  Default = false,
  Callback = function(state)
    if state == true then
        if headSit then 
            headSit:Disconnect()
        end

        local playerName = string.match(Target, "%(([^)]+)%)")
        local players = game.Players:FindFirstChild(playerName)
        if players and players.Character then
            local sitPlr = players.Name

            sitDied = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Died:Connect(function()
                if sitLoop then
                    sitLoop:Disconnect()
                end
            end)

            game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Sit = true

            headSit = RunService.Heartbeat:Connect(function()
                if game.Players:FindFirstChild(players.Name) 
                and players.Character 
                and getRoot(players.Character) 
                and getRoot(game.Players.LocalPlayer.Character) 
                and game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid').Sit == true then
                    getRoot(game.Players.LocalPlayer.Character).CFrame = players.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(0), 0) * CFrame.new(0, 1.6, 0.4)
                else
                    headSit:Disconnect()
                end
            end)
        end
    else
        if headSit then 
            headSit:Disconnect()
        end

        -- Avoid forcing jump when the toggle is turned off, just ensure not sitting
        local humanoid = game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
        if humanoid and humanoid.Sit then
            humanoid.Sit = false -- Ensure the player is no longer sitting
        end
    end
  end    
})

local plr = game.Players.LocalPlayer
local WalkTo = false

local function getRoot(character)
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("LowerTorso")
end

local function getTargetPlayer()
    if not Target then
        return nil
    end
    local playerName = string.match(Target, "%(([^)]+)%)")
    return game.Players:FindFirstChild(playerName)
end

Player:AddToggle({
    Name = "Walk To",
    Default = false,
    Callback = function(Walkn)
        if Walkn then
            local target = getTargetPlayer()
            if not target or not target.Character then
                warn("Target player not found or does not have a character.")
                return
            end

            local humanoid = plr.Character:FindFirstChildOfClass('Humanoid')
            if humanoid and humanoid.SeatPart then
                humanoid.Sit = false
                wait(0.1)
            end

            if not WalkTo then
                WalkTo = true
                while WalkTo do
                    wait()
                    local targetRoot = getRoot(target.Character)
                    if targetRoot then
                        humanoid:MoveTo(targetRoot.Position)
                    else
                        WalkTo = false
                    end

                    -- Exit loop if target is invalid
                    if not target.Character or not getRoot(target.Character) then
                        WalkTo = false
                    end
                end
            end
        else
            WalkTo = false
        end
    end    
})

Player:AddToggle({
    Name = "Pathfind Walk To",
    Default = false,
    Callback = function(Walkns)
        if Walkns then
            WalkTo = false -- Ensure the first toggle stops walking
            local target = getTargetPlayer()
            if not target or not target.Character then
                warn("Target player not found or does not have a character.")
                return
            end

            local PathService = game:GetService("PathfindingService")
            local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
            if not humanoid then
                warn("Humanoid not found in player's character.")
                return
            end

            local path = PathService:CreatePath({
                AgentRadius = 2,
                AgentHeight = 5,
                AgentCanJump = true,
                AgentWalksOnWater = true,
            })

            local function computePath()
                local startPos = getRoot(plr.Character).Position
                local endPos = getRoot(target.Character).Position
                path:ComputeAsync(startPos, endPos)
                return path
            end

            if not WalkTo then
                WalkTo = true
                while WalkTo do
                    wait()
                    local success, result = pcall(computePath)
                    if success then
                        local waypoints = path:GetWaypoints()
                        for _, waypoint in ipairs(waypoints) do
                            if not WalkTo then break end
                            humanoid:MoveTo(waypoint.Position)
                            humanoid.MoveToFinished:Wait()
                            if waypoint.Action == Enum.PathWaypointAction.Jump then
                                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                            end
                        end
                    else
                        -- Fallback to simple MoveTo if pathfinding fails
                        humanoid:MoveTo(getRoot(target.Character).Position)
                    end

                    -- Exit loop if target is invalid
                    if not target.Character or not getRoot(target.Character) then
                        WalkTo = false
                    end
                end
            end
        else
            WalkTo = false
        end
    end    
})

local Players = game:GetService("Players")
local Staring

Player:AddToggle({
    Name = "Stare",
    Default = false,
    Callback = function(Stare)
        if Stare then
        local playerName = string.match(Target, "%(([^)]+)%)")
            local Target = game.Players:FindFirstChild(playerName)
            if Staring then
                Staring:Disconnect()
            end
            if not Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or not Target.Character:FindFirstChild("HumanoidRootPart") then
                return
            end
            local function StareAtTarget()
                if Players.LocalPlayer.Character.PrimaryPart and Players:FindFirstChild(Target.Name) and Target.Character and Target.Character:FindFirstChild("HumanoidRootPart") then
                    local CharPos = Players.LocalPlayer.Character.PrimaryPart.Position
                    local tpos = Target.Character:FindFirstChild("HumanoidRootPart").Position
                    local TPos = Vector3.new(tpos.X, CharPos.Y, tpos.Z)
                    local NewCFrame = CFrame.new(CharPos, TPos)
                    Players.LocalPlayer.Character:SetPrimaryPartCFrame(NewCFrame)
                elseif not Players:FindFirstChild(Target.Name) then
                    Staring:Disconnect()
                end
            end

            Staring = game:GetService("RunService").RenderStepped:Connect(StareAtTarget)
        else
            if Staring then
                Staring:Disconnect()
            end
        end
    end    
})

wait(0.2)

local NPC = Window:MakeTab({
	Name = "NPCS",
	Icon = "rbxassetid://6034287516",
	PremiumOnly = false --- Set true, if you want to this tab was only for premium people, or false to all could use this.
})

NPC:AddLabel("Beta Version")

local function GetNPC(searchString)
    local foundNPCs = {}
    local lowerSearch = searchString:lower()

    for _, descendant in ipairs(workspace:GetDescendants()) do
        if descendant:IsA("Model") and descendant.Name:lower():find(lowerSearch, 1, true) then
            table.insert(foundNPCs, descendant)
        end
    end

    return foundNPCs
end

local NPCTarget

-- Textbox for NPC name input with better feedback handling
NPC:AddTextbox({
    Name = "NPC Name",
    Default = "",
    TextDisappear = true,
    Callback = function(inputText)
        local targetNPCs = GetNPC(inputText)
        if #targetNPCs > 0 then
            NPCTarget = targetNPCs[1]  -- Select the first matching NPC
            OrionLib:MakeNotification({
                Name = "NPC Selected",
                Content = "NPC: " .. NPCTarget.Name .. " selected!",
                Image = "rbxassetid://6031075938",
                Time = 5
            })
        else
            OrionLib:MakeNotification({
                Name = "NPC Not Found",
                Content = "No NPC found matching that name.",
                Image = "rbxassetid://6031075938",
                Time = 5
            })
        end
    end
})

NPC:AddButton({
    Name = "Click At NPC",
    Callback = function()
        local ClickTool = Instance.new("Tool")
        ClickTool.Name = "ClickNPC"
        ClickTool.RequiresHandle = false
        ClickTool.ToolTip = "Select NPC by Clicking"

        -- Tool activation logic
        ClickTool.Activated:Connect(function()
            local player = game.Players.LocalPlayer
            local mouse = player:GetMouse()
            local hit = mouse.Target

            if hit and hit.Parent:IsA("Model") then
                NPCTarget = hit.Parent
                SelectedNPC = NPCTarget.Name
                OrionLib:MakeNotification({
                    Name = "NPC Selected",
                    Content = "Selected NPC: " .. SelectedNPC,
                    Image = "rbxassetid://6031075938",
                    Time = 5
                })
            else
                OrionLib:MakeNotification({
                    Name = "Selection Failed",
                    Content = "Please click on a valid NPC.",
                    Image = "rbxassetid://6031075938",
                    Time = 5
                })
            end
        end)

        -- Add tool to the player's backpack
        ClickTool.Parent = game.Players.LocalPlayer.Backpack
    end
})

NPC:AddToggle({
	Name = "Walk To NPC",
	Default = false,
	Callback = function(Walkn)
        if Walkn == true then
            if plr.Character:FindFirstChildOfClass('Humanoid') and plr.Character:FindFirstChildOfClass('Humanoid').SeatPart then
		plr.Character:FindFirstChildOfClass('Humanoid').Sit = false
		wait(.1)
	end
	    if WalkTo == false then
		WalkTo = true
		repeat wait()
		     plr.Character:FindFirstChild("Humanoid"):MoveTo(getRoot(NPCTarget).Position)
			 until NPCTarget == nil or not getRoot(NPCTarget) or WalkTo == false	
	end
		else
		    Walkn = false
			WalkTo = false
		end		
  end    
})

NPC:AddToggle({
	Name = "Pathfind Walk To NPC",
	Default = false,
	Callback = function(Walkns)
        if Walkns == true then
            WalkTo = false
	local PathService = game:GetService("PathfindingService")
	local hum = plr.Character:FindFirstChildOfClass("Humanoid")
	local path = PathService:CreatePath()
	
	if WalkTo == false then
		WalkTo = true
	repeat wait()
		local success, response = pcall(function()
			path:ComputeAsync(getRoot(plr.Character).Position, getRoot(NPCTarget).Position)
			local waypoints = path:GetWaypoints()
			local distance 
			for waypointIndex, waypoint in pairs(waypoints) do
				local waypointPosition = waypoint.Position
				hum:MoveTo(waypointPosition)
				repeat 
					distance = (waypointPosition - hum.Parent.PrimaryPart.Position).magnitude
					wait()
				until
				distance <= 5
			end	 
		end)
		if not success then
			plr.Character:FindFirstChildOfClass('Humanoid'):MoveTo(getRoot(NPCTarget).Position)
		end
		until NPCTarget == nil or not getRoot(NPCTarget) or WalkTo == false
		end
		else
		    Walkns = false
			WalkTo = false
		end		
  end    
})

local Control = false  
local plr = game.Players.LocalPlayer


NPC:AddToggle({
    Name = "Control NPC",
    Default = false,
    Callback = function(Controlwho)
        if Controlwho and NPCTarget then  

 -- Variables
local mouse = game.Players.LocalPlayer:GetMouse()
local uis = game:GetService("UserInputService")

-- Connect

local npc = NPCTarget
local npcRootPart = npc.HumanoidRootPart
local PlayerCharacter = game:GetService("Players").LocalPlayer.Character
local PlayerRootPart = PlayerCharacter.HumanoidRootPart
local A0 = Instance.new("Attachment")
local AP = Instance.new("AlignPosition")
local AO = Instance.new("AlignOrientation")
local A1 = Instance.new("Attachment")
for _, v in pairs(npc:GetDescendants()) do
if v:IsA("BasePart") then
game:GetService("RunService").Stepped:Connect(function()
v.CanCollide = false
end)
end
end
PlayerRootPart:BreakJoints()
for _, v in pairs(PlayerCharacter:GetDescendants()) do
if v:IsA("BasePart") then
if v.Name == "HumanoidRootPart" or v.Name == "UpperTorso" or v.Name == "Head" then
else
v:Destroy()
end
end
end
PlayerRootPart.Position = PlayerRootPart.Position+Vector3.new(5, 0, 0)
PlayerCharacter.Head.Anchored = true
PlayerCharacter.UpperTorso.Anchored = true
A0.Parent = npcRootPart
AP.Parent = npcRootPart
AO.Parent = npcRootPart
AP.Responsiveness = 200
AP.MaxForce = math.huge
AO.MaxTorque = math.huge
AO.Responsiveness = 200
AP.Attachment0 = A0
AP.Attachment1 = A1
AO.Attachment1 = A1
AO.Attachment0 = A0
A1.Parent = PlayerRootPart
else

end
    end
})

NPC:AddButton({
	Name = "tp unAnchored Parts to NPC",
	Callback = function()
		if sethidden then
			local Forces = {}
			for _,part in pairs(game.Workspace:GetDescendants()) do
				if NPCTarget:FindFirstChild("Head") and part:IsA("BasePart" or "UnionOperation" or "Model") and part.Anchored == false and not part:IsDescendantOf(plr.Character) and part.Name == "Torso" == false and part.Name == "Head" == false and part.Name == "Right Arm" == false and part.Name == "Left Arm" == false and part.Name == "Right Leg" == false and part.Name == "Left Leg" == false and part.Name == "HumanoidRootPart" == false then
					for i,c in pairs(part:GetChildren()) do
						if c:IsA("BodyPosition") or c:IsA("BodyGyro") then
							c:Destroy()
						end
					end
					local ForceInstance = Instance.new("BodyPosition")
					ForceInstance.Parent = part
					ForceInstance.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
					table.insert(Forces, ForceInstance)
					if not table.find(frozenParts,part) then
						table.insert(frozenParts,part)
					end
				end
			end
			if not simRadius then
				SimRad()
			end
			for i,c in pairs(Forces) do
				c.Position = NPCTarget.Head.Position
			end
		end
	end    
})

NPC:AddButton({
	Name = "Teleport To NPC",
	Callback = function()
      	plr.Character.HumanoidRootPart.CFrame = NPCTarget:GetModelCFrame()
  	end    
})

NPC:AddButton({
	Name = "Vehicle Teleport to NPC",
	Callback = function()
		if NPCTarget ~= nil then
			local seat = plr.Character:FindFirstChildOfClass('Humanoid').SeatPart
			local vehicleModel = seat.Parent
			repeat
				if vehicleModel.ClassName ~= "Model" then
					vehicleModel = vehicleModel.Parent
				end
			until vehicleModel.ClassName == "Model"
			for i,v in pairs(vehicleModel:GetDescendants()) do
				if v:IsA("BasePart") then
				   v:MoveTo(NPCTarget.HumanoidRootPart.Position)
				end   
			end
			for i,v in pairs(vehicleModel.Parent:GetDescendants()) do
				if v:IsA("BasePart") and v.Anchored then
					if v.Anchored == false then
				   v:MoveTo(NPCTarget.HumanoidRootPart.Position)
				   end
				end   
			end
			wait(0.1)
			vehicleModel:MoveTo(NPCTarget.HumanoidRootPart.Position)
	end
	end    
})

NPC:AddButton({
	Name = "Fling Noclipped NPC",
	Callback = function()
flinghh = 1000
local lp = game.Players.LocalPlayer

if type(NPCTarget) == "string" then return end

local oldpos = lp.Character.HumanoidRootPart.CFrame
local oldhh = lp.Character.Humanoid.HipHeight

local carpetAnim = Instance.new("Animation")
carpetAnim.AnimationId = "rbxassetid://282574440"
carpet = lp.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(carpetAnim)
carpet:Play(.1, 1, 1)

local carpetLoop

local tTorso = NPCTarget:FindFirstChild("Torso") or NPCTarget:FindFirstChild("LowerTorso") or NPCTarget:FindFirstChild("HumanoidRootPart")

spawn(function()
    carpetLoop = game:GetService('RunService').Heartbeat:Connect(function()
	    pcall(function()
	        if tTorso.Velocity.magnitude <= 28 then -- if target uses netless just target their local position
    	        local pos = {x=0, y=0, z=0}
        		pos.x = tTorso.Position.X
        		pos.y = tTorso.Position.Y
        		pos.z = tTorso.Position.Z
        		pos.x = pos.x + tTorso.Velocity.X / 2
        		pos.y = pos.y + tTorso.Velocity.Y / 2
        		pos.z = pos.z + tTorso.Velocity.Z / 2
    		    lp.Character.HumanoidRootPart.CFrame = CFrame.new(Vector3.new(pos.x,pos.y,pos.z))
    		else
    		    lp.Character.HumanoidRootPart.CFrame = tTorso.CFrame
		    end
	    end)
    end)
end)

wait()

lp.Character.Humanoid.HipHeight = flinghh

wait(.5)

carpetLoop:Disconnect()
wait()
lp.Character.Humanoid.Health = 0
wait(game.Players.RespawnTime + .6)
lp.Character.HumanoidRootPart.CFrame = oldpos
  	end    
})

NPC:AddToggle({
	Name = "View NPC",
	Default = false,
	Callback = function(View)
        if View == true then
		viewing = NPCTarget
		game.Workspace.CurrentCamera.CameraSubject = viewing
		else
		    View = false
	game.Workspace.CurrentCamera.CameraSubject = plr.Character
		end		
  end    
})

NPC:AddButton({
	Name = "Information about NPC",
	Callback = function()
      	OrionLib:MakeNotification({
	Name = "Information about NPC:",
	Content = 'Name: '..NPCTarget.Name..' | Health: '..round(NPCTarget:FindFirstChildOfClass('Humanoid').Health, 1)..' | WalkSpeed: '..NPCTarget:FindFirstChildOfClass("Humanoid").WalkSpeed..' | JumpPower: '..NPCTarget:FindFirstChildOfClass("Humanoid").JumpPower,
	Image = "",
	Time = 10
})
  	end    
})

NPC:AddToggle({
	Name = "Stare At NPC",
	Default = false,
	Callback = function(Stareqs)
        if Stareqs == true then
		if stareLoop then
			stareLoop:Disconnect()
		end
		if not plr.Character:FindFirstChild("HumanoidRootPart") and NPCTarget:FindFirstChild("HumanoidRootPart") then return end
		local function stareFunc()
			if plr.Character.PrimaryPart and NPCTarget ~= nil and NPCTarget:FindFirstChild("HumanoidRootPart") then
				local chrPos= plr.Character.PrimaryPart.Position
				local tPos= NPCTarget:FindFirstChild("HumanoidRootPart").Position
				local modTPos=Vector3.new(tPos.X,chrPos.Y,tPos.Z)
				local newCF=CFrame.new(chrPos,modTPos)
				plr.Character:SetPrimaryPartCFrame(newCF)
			elseif not NPCTarget:FindFirstChild(v) then
				stareLoop:Disconnect()
			end
		end

		stareLoop = game:GetService("RunService").RenderStepped:Connect(stareFunc)
		else
		    Stareqs = false
			if stareLoop then
		stareLoop:Disconnect()
	end
		end		
  end    
})

NPC:AddToggle({
	Name = "Fling NPC",
	Default = false,
	Callback = function(Flinglols)
        if Flinglols == true then
            plr.Character.Humanoid.PlatformStand = Platformstand
			Flinging = true
	local Thrust = Instance.new("BodyThrust", plr.Character.HumanoidRootPart)
	Thrust.Force = Vector3.new(100000, 100000, 100000)
	Thrust.Name = "FlingForce"
	repeat
		plr.Character.HumanoidRootPart.CFrame = NPCTarget.HumanoidRootPart.CFrame
		Thrust.Location = getRoot(NPCTarget).Position
		game:GetService('RunService').Heartbeat:Wait()
	until not getRoot(NPCTarget) or Flinging == false
		else
		    Flinglols = false
			Flinging = false
			plr.Character.Humanoid.PlatformStand = false
	for i,v in pairs(plr.Character.HumanoidRootPart:GetChildren()) do
		if v.Name == "FlingForce" and v:IsA("BodyThrust") then
			v:Destroy()
		end
	end
		end		
  end    
})

NPC:AddToggle({
	Name = "PlatformStand Fling",
	Default = false,
	Callback = function(pzFlinglol)
        if pzFlinglol == true then
            Platformstand = true
		else
		    pzFlinglol = false
			Platformstand = false
		end		
  end    
})

NPC:AddButton({
	Name = "ToolHandle Kill NPC",
	Callback = function()
      	local Char = plr.Character
local RS = game:GetService("RunService").RenderStepped
local Tool = Char:FindFirstChildWhichIsA("Tool")
local Handle = Tool and Tool:FindFirstChild("Handle")
if not Tool or not Handle then
   return game.StarterGui:SetCore("SendNotification", {Title = "Warning!", Text = "You need to hold a 'Tool' that does damage on touchinterest. For example Sword or Knife.", Duration = 4,})
end
task.spawn(function()
   while Tool and Char and NPCTarget and Tool.Parent == Char do
           local Human = NPCTarget:FindFirstChildWhichIsA("Humanoid")
           if not Human or Human.Health <= 0 then
                   break
           end
           for i, v1 in ipairs(NPCTarget:GetChildren()) do
                   v1 = ((v1:IsA("BasePart") and firetouchinterest(Handle, v1, 1, (RS.Wait(RS) and nil) or firetouchinterest(Handle, v1, 0)) and nil) or v1) or v1
           end
   end
   game.StarterGui:SetCore("SendNotification", {Title = "Done!", Text = "ToolHandle Kill Stopped. Because npc died or you just unequipped the tool.", Duration = 4,})
end)
  	end    
})

NPC:AddButton({
	Name = "Look At NPC",
	Callback = function()
      	local preMaxZoom = game.Players.LocalPlayer.CameraMaxZoomDistance
	local preMinZoom = game.Players.LocalPlayer.CameraMinZoomDistance
	if plr.CameraMaxZoomDistance ~= 0.5 then
		preMaxZoom = plr.CameraMaxZoomDistance
		preMinZoom = plr.CameraMinZoomDistance
	end
	plr.CameraMaxZoomDistance = 0.5
	plr.CameraMinZoomDistance = 0.5
	wait()
		if NPCTarget and NPCTarget:FindFirstChild('Head') then
			game.Workspace.CurrentCamera.CFrame = CFrame.new(game.Workspace.CurrentCamera.CFrame.p, NPCTarget.Head.CFrame.p)
			wait(0.1)
		end
	plr.CameraMaxZoomDistance = preMaxZoom
	plr.CameraMinZoomDistance = preMinZoom
  	end    
})

end
